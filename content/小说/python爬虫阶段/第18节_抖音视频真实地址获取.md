---
title: "第18节_抖音视频真实地址获取"
slug: "第18节_抖音视频真实地址获取"
date: "2025-04-25T01:00:45.386623+00:00"
---

# 第18节：抖音视频真实地址获取

## 学习目标

- **<font color="red">掌握抖音视频真实地址的加密原理</font>**
- **<font color="blue">学习使用js2py工具逆向解析JavaScript代码</font>**
- **<font color="green">理解抖音视频地址批量加密和解密方式</font>**
- **<font color="purple">熟练分析和提取视频真实播放地址</font>**
- **<font color="orange">掌握绕过高级反爬措施的技巧</font>**

## 知识点

### 抖音视频地址加密机制

- **<font color="red">加密原理</font>**：
  - URL参数签名机制
  - 时间戳验证
  - 动态密钥生成
  - 多层次加密处理
  - 请求头验证

- **<font color="blue">加密特点</font>**：
  - 前端JavaScript实现
  - 定期更新算法
  - 多重混淆保护
  - 环境检测机制
  - 反调试技术

- **<font color="green">解密策略</font>**：
  - 提取加密算法
  - 模拟执行环境
  - 参数构造与验证
  - 动态追踪调用
  - 绕过环境检测

### JavaScript逆向分析技术

- **<font color="red">逆向分析工具</font>**：
  - 浏览器开发者工具
  - JavaScript调试器
  - 代码美化工具
  - AST语法树分析
  - 网络请求监控

- **<font color="blue">关键技术点</font>**：
  - 断点调试技术
  - 变量跟踪分析
  - 函数调用栈检查
  - 代码去混淆处理
  - 环境模拟构建

- **<font color="green">js2py工具使用</font>**：
  - 环境配置与安装
  - JavaScript代码转Python
  - 上下文环境模拟
  - 函数调用与参数传递
  - 异常处理机制

### 批量获取视频真实地址

- **<font color="red">批量处理策略</font>**：
  - 多线程并发请求
  - 任务队列管理
  - 错误重试机制
  - 结果统一处理
  - 资源释放控制

- **<font color="blue">性能优化</font>**：
  - 连接池复用
  - 请求频率控制
  - 内存占用优化
  - 异步处理模式
  - 缓存机制应用

- **<font color="green">反爬对策</font>**：
  - 随机延时策略
  - User-Agent轮换
  - IP代理池使用
  - 请求参数随机化
  - Cookie管理机制

## 典型示例

### 分析抖音视频页面JavaScript加密代码

```python
import requests
import re
import json
import js2py
import time
import random

# 设置请求头
headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
    'Referer': 'https://www.douyin.com/',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',
    'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8'
}

# 获取抖音视频页面
def get_video_page(url):
    try:
        response = requests.get(url, headers=headers, timeout=10)
        if response.status_code == 200:
            return response.text
        else:
            print(f"请求失败，状态码：{response.status_code}")
            return ""
    except Exception as e:
        print(f"请求异常：{e}")
        return ""

# 提取JavaScript加密代码
def extract_js_code(html):
    # 查找包含加密逻辑的JavaScript代码块
    js_pattern = r'<script>\s*window\.byted_acrawler\s*=\s*\{([\s\S]*?)\}\s*</script>'
    js_match = re.search(js_pattern, html)
    
    if js_match:
        # 提取完整的JavaScript代码块
        js_code = f"window.byted_acrawler = {{{js_match.group(1)}}};"
        return js_code
    
    # 尝试其他可能的模式
    alt_pattern = r'<script[^>]*src="([^"]*acrawler[^"]*\.js)"[^>]*>'
    alt_match = re.search(alt_pattern, html)
    
    if alt_match:
        js_url = alt_match.group(1)
        if not js_url.startswith('http'):
            js_url = 'https:' + js_url if js_url.startswith('//') else 'https://www.douyin.com' + js_url
        
        try:
            js_response = requests.get(js_url, headers=headers)
            if js_response.status_code == 200:
                return js_response.text
        except Exception as e:
            print(f"获取JS文件失败：{e}")
    
    return ""

# 分析并提取关键加密函数
def analyze_js_code(js_code):
    if not js_code:
        return None
    
    # 查找签名生成函数
    sign_func_pattern = r'function\s+([a-zA-Z0-9_$]+)\s*\([^)]*\)\s*{[\s\S]*?sign[\s\S]*?return[\s\S]*?}'
    sign_func_match = re.search(sign_func_pattern, js_code)
    
    if sign_func_match:
        # 提取函数名
        func_name = sign_func_match.group(1)
        print(f"找到疑似签名函数: {func_name}")
        
        # 构造可执行的JavaScript代码
        executable_js = js_code + f"\n\nfunction getSign(url) {{ return {func_name}(url); }}"
        return executable_js
    
    return None
```

### 使用js2py执行JavaScript代码获取签名

```python
# 使用js2py执行JavaScript代码
def execute_js_with_js2py(js_code, url):
    if not js_code:
        return None
    
    try:
        # 创建JavaScript执行环境
        context = js2py.EvalJs()
        
        # 添加必要的浏览器环境变量
        browser_env = """
        var window = {};
        var document = {
            createElement: function() { return {}; },
            body: { appendChild: function() {} },
            location: { href: "https://www.douyin.com/", protocol: "https:" }
        };
        var navigator = {
            userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
        };
        """
        
        # 执行环境初始化代码
        context.execute(browser_env)
        
        # 执行提取的JavaScript代码
        context.execute(js_code)
        
        # 调用签名函数获取签名
        result = context.eval(f"getSign('{url}')")
        return result
    
    except Exception as e:
        print(f"执行JavaScript代码异常：{e}")
        return None

# 构造带签名的URL
def build_signed_url(url, signature):
    if not signature:
        return url
    
    # 检查URL是否已有参数
    if '?' in url:
        return f"{url}&_signature={signature}"
    else:
        return f"{url}?_signature={signature}"
```

### 获取视频真实播放地址

```python
# 从加密地址获取真实播放地址
def get_real_video_url(encrypted_url):
    try:
        # 发送请求获取重定向地址
        response = requests.head(encrypted_url, headers=headers, allow_redirects=False)
        
        # 检查是否有重定向
        if response.status_code in (301, 302) and 'Location' in response.headers:
            real_url = response.headers['Location']
            return real_url
        
        # 如果没有重定向，尝试直接访问
        if response.status_code == 200:
            return encrypted_url
        
        print(f"获取真实地址失败，状态码：{response.status_code}")
        return None
    
    except Exception as e:
        print(f"获取真实地址异常：{e}")
        return None

# 从HTML中提取加密的视频地址
def extract_encrypted_video_url(html):
    # 尝试从JavaScript变量中提取
    js_data_pattern = r'\"playAddr\":\s*\"([^\"]+)\"'
    js_data_match = re.search(js_data_pattern, html)
    
    if js_data_match:
        encrypted_url = js_data_match.group(1)
        # URL解码
        encrypted_url = encrypted_url.replace('\\u002F', '/')
        return encrypted_url
    
    # 尝试从视频元素中提取
    video_element_pattern = r'<video[^>]*src="([^"]+)"[^>]*>'
    video_element_match = re.search(video_element_pattern, html)
    
    if video_element_match:
        return video_element_match.group(1)
    
    return None
```

## 实际示例

### 完整的抖音视频真实地址获取流程

```python
import requests
import re
import js2py
import json
import time
import random
from concurrent.futures import ThreadPoolExecutor

# 设置请求头
headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
    'Referer': 'https://www.douyin.com/',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',
    'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8'
}

# 代理IP池（示例）
proxy_pool = [
    "http://127.0.0.1:7890",
    # 添加更多代理
]

# 随机获取代理
def get_random_proxy():
    if proxy_pool:
        return {"http": random.choice(proxy_pool), "https": random.choice(proxy_pool)}
    return None

# 获取抖音视频页面
def get_video_page(url):
    try:
        proxy = get_random_proxy()
        response = requests.get(url, headers=headers, proxies=proxy, timeout=10)
        if response.status_code == 200:
            return response.text
        else:
            print(f"请求失败，状态码：{response.status_code}")
            return ""
    except Exception as e:
        print(f"请求异常：{e}")
        return ""

# 提取JavaScript加密代码
def extract_js_code(html):
    # 查找包含加密逻辑的JavaScript代码块
    js_pattern = r'<script>\s*window\.byted_acrawler\s*=\s*\{([\s\S]*?)\}\s*</script>'
    js_match = re.search(js_pattern, html)
    
    if js_match:
        # 提取完整的JavaScript代码块
        js_code = f"window.byted_acrawler = {{{js_match.group(1)}}};"
        return js_code
    
    # 尝试其他可能的模式
    alt_pattern = r'<script[^>]*src="([^"]*acrawler[^"]*\.js)"[^>]*>'
    alt_match = re.search(alt_pattern, html)
    
    if alt_match:
        js_url = alt_match.group(1)
        if not js_url.startswith('http'):
            js_url = 'https:' + js_url if js_url.startswith('//') else 'https://www.douyin.com' + js_url
        
        try:
            js_response = requests.get(js_url, headers=headers)
            if js_response.status_code == 200:
                return js_response.text
        except Exception as e:
            print(f"获取JS文件失败：{e}")
    
    return ""

# 分析并提取关键加密函数
def analyze_js_code(js_code):
    if not js_code:
        return None
    
    # 查找签名生成函数
    sign_func_pattern = r'function\s+([a-zA-Z0-9_$]+)\s*\([^)]*\)\s*{[\s\S]*?sign[\s\S]*?return[\s\S]*?}'
    sign_func_match = re.search(sign_func_pattern, js_code)
    
    if sign_func_match:
        # 提取函数名
        func_name = sign_func_match.group(1)
        print(f"找到疑似签名函数: {func_name}")
        
        # 构造可执行的JavaScript代码
        executable_js = js_code + f"\n\nfunction getSign(url) {{ return {func_name}(url); }}"
        return executable_js
    
    return None

# 使用js2py执行JavaScript代码
def execute_js_with_js2py(js_code, url):
    if not js_code:
        return None
    
    try:
        # 创建JavaScript执行环境
        context = js2py.EvalJs()
        
        # 添加必要的浏览器环境变量
        browser_env = """
        var window = {};
        var document = {
            createElement: function() { return {}; },
            body: { appendChild: function() {} },
            location: { href: "https://www.douyin.com/", protocol: "https:" }
        };
        var navigator = {
            userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
        };
        """
        
        # 执行环境初始化代码
        context.execute(browser_env)
        
        # 执行提取的JavaScript代码
        context.execute(js_code)
        
        # 调用签名函数获取签名
        result = context.eval(f"getSign('{url}')")
        return result
    
    except Exception as e:
        print(f"执行JavaScript代码异常：{e}")
        return None

# 从HTML中提取加密的视频地址
def extract_encrypted_video_url(html):
    # 尝试从JavaScript变量中提取
    js_data_pattern = r'\"playAddr\":\s*\"([^\"]+)\"'
    js_data_match = re.search(js_data_pattern, html)
    
    if js_data_match:
        encrypted_url = js_data_match.group(1)
        # URL解码
        encrypted_url = encrypted_url.replace('\\u002F', '/')
        return encrypted_url
    
    # 尝试从视频元素中提取
    video_element_pattern = r'<video[^>]*src="([^"]+)"[^>]*>'
    video_element_match = re.search(video_element_pattern, html)
    
    if video_element_match:
        return video_element_match.group(1)
    
    return None

# 从加密地址获取真实播放地址
def get_real_video_url(encrypted_url):
    try:
        # 发送请求获取重定向地址
        proxy = get_random_proxy()
        response = requests.head(encrypted_url, headers=headers, proxies=proxy, allow_redirects=False)
        
        # 检查是否有重定向
        if response.status_code in (301, 302) and 'Location' in response.headers:
            real_url = response.headers['Location']
            return real_url
        
        # 如果没有重定向，尝试直接访问
        if response.status_code == 200:
            return encrypted_url
        
        print(f"获取真实地址失败，状态码：{response.status_code}")
        return None
    
    except Exception as e:
        print(f"获取真实地址异常：{e}")
        return None

# 完整的获取视频真实地址流程
def get_douyin_video_real_url(video_url):
    print(f"\n开始处理视频: {video_url}")
    
    # 1. 获取视频页面
    html = get_video_page(video_url)
    if not html:
        print("获取视频页面失败")
        return None
    
    # 2. 提取加密的视频地址
    encrypted_url = extract_encrypted_video_url(html)
    if not encrypted_url:
        print("未找到加密的视频地址")
        return None
    
    print(f"找到加密的视频地址: {encrypted_url}")
    
    # 3. 提取JavaScript加密代码
    js_code = extract_js_code(html)
    if not js_code:
        print("未找到JavaScript加密代码，尝试直接获取真实地址")
        return get_real_video_url(encrypted_url)
    
    # 4. 分析JavaScript代码并提取关键函数
    executable_js = analyze_js_code(js_code)
    if not executable_js:
        print("分析JavaScript代码失败，尝试直接获取真实地址")
        return get_real_video_url(encrypted_url)
    
    # 5. 使用js2py执行JavaScript代码获取签名
    signature = execute_js_with_js2py(executable_js, video_url)
    if not signature:
        print("获取签名失败，尝试直接获取真实地址")
        return get_real_video_url(encrypted_url)
    
    print(f"成功获取签名: {signature}")
    
    # 6. 构造带签名的URL
    signed_url = encrypted_url
    if '?' in encrypted_url:
        signed_url = f"{encrypted_url}&_signature={signature}"
    else:
        signed_url = f"{encrypted_url}?_signature={signature}"
    
    print(f"构造带签名的URL: {signed_url}")
    
    # 7. 获取真实播放地址
    real_url = get_real_video_url(signed_url)
    if real_url:
        print(f"成功获取真实播放地址: {real_url}")
    else:
        print("获取真实播放地址失败")
    
    return real_url

# 批量处理视频URL
def batch_process_videos(video_urls, max_workers=3):
    results = {}
    
    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        future_to_url = {executor.submit(get_douyin_video_real_url, url): url for url in video_urls}
        
        for future in future_to_url:
            url = future_to_url[future]
            try:
                real_url = future.result()
                results[url] = real_url
                # 随机延时，避免请求过于频繁
                time.sleep(random.uniform(2, 5))
            except Exception as e:
                print(f"处理视频 {url} 时发生异常: {e}")
                results[url] = None
    
    return results

# 示例使用
if __name__ == "__main__":
    # 单个视频处理
    video_url = "https://www.douyin.com/video/7123456789012345678"
    real_url = get_douyin_video_real_url(video_url)
    
    if real_url:
        print(f"\n最终结果 - 视频真实地址: {real_url}")
    else:
        print("\n获取视频真实地址失败")
    
    # 批量处理示例
    video_urls = [
        "https://www.douyin.com/video/7123456789012345678",
        "https://www.douyin.com/video/7123456789012345679",
        "https://www.douyin.com/video/7123456789012345680"
    ]
    
    print("\n开始批量处理视频...")
    results = batch_process_videos(video_urls, max_workers=2)
    
    print("\n批量处理结果:")
    for url, real_url in results.items():
        if real_url:
            print(f"视频 {url} 的真实地址: {real_url}")
        else:
            print(f"视频 {url} 获取真实地址失败")
```

## 思考题

1. 抖音视频真实地址的加密机制与其他视频平台相比有何特点？这些特点对爬虫开发带来了哪些挑战？
2. 在使用js2py执行JavaScript代码时，为什么需要模拟浏览器环境？如何更全面地模拟这个环境？
3. 批量获取抖音视频真实地址时，如何平衡爬取效率和反爬风险？有哪些优化策略？
4. 抖音经常更新其加密算法，如何设计一个可维护的爬虫系统来应对这些变化？
5. 从技术角度考虑，抖音还可能采用哪些更高级的反爬措施？如何预先准备应对策略？
  
## 小结

- **<font color="red">抖音视频真实地址获取需要分析并执行前端JavaScript加密代码</font>**
- **<font color="blue">js2py是Python中执行JavaScript代码的有效工具</font>**
- **<font color="green">批量处理需要合理控制并发和请求频率</font>**
- **<font color="purple">模拟浏览器环境是成功执行加密代码的关键</font>**
- **<font color="orange">获取真实地址通常需要处理多次重定向</font>**

## 总结

本节课深入讲解了抖音视频真实地址的获取方法。抖音作为流行的短视频平台，采用了复杂的加密机制来保护视频资源，这给爬虫开发带来了挑战。通过学习JavaScript逆向分析技术，特别是使用js2py工具执行前端加密代码，我们可以成功获取视频的真实播放地址。

在实际操作中，我们需要分析抖音页面中的JavaScript代码，提取关键的加密函数，然后在Python环境中模拟执行这些函数，生成必要的签名参数。此外，我们还学习了如何处理批量请求，包括使用多线程、代理IP池和随机延时等技术，以提高效率并降低被封风险。

掌握这些技术后，我们不仅能够获取抖音视频的真实地址，还能将这些方法应用到其他具有类似保护机制的网站。同时，我们也要注意合法合规地使用这些技术，尊重平台规则和内容创作者的权益。在下一节课中，我们将学习如何将获取到的视频保存到本地，并进行简单的处理和分析。