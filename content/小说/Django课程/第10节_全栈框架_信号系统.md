---
title: "第10节_全栈框架_信号系统"
slug: "第10节_全栈框架_信号系统"
date: "2025-05-19T12:20:42.222192+00:00"
---

# 第10节：全栈框架_信号系统

## 来源

信号系统是Django框架中实现组件间松耦合通信的重要机制。在复杂的Web应用程序中，不同组件之间常常需要在特定事件发生时进行通信，而直接的函数调用可能导致组件间的紧耦合。Django的信号系统提供了一种基于发布-订阅模式的解决方案，允许发送者在不知道接收者的情况下发送通知，接收者在不知道发送者的情况下接收通知，从而实现组件间的松耦合。信号系统广泛应用于模型的生命周期事件、请求/响应处理、用户认证等场景，是Django应用程序中实现事件驱动编程的重要工具。

## 定义

### 信号系统的概念

信号系统是一种基于发布-订阅模式的事件通知机制，允许在特定事件发生时发送通知，并由注册的接收者处理这些通知。在Django中，信号系统由以下部分组成：

1. **信号**：代表特定事件的对象，如模型保存、用户登录等。
2. **发送者**：触发信号的对象，如模型实例、请求对象等。
3. **接收者**：处理信号的函数或方法。
4. **连接**：将接收者与信号关联起来的过程。

### 内置信号

Django提供了多个内置信号，用于处理常见的事件：

#### 模型信号

- `pre_save`：在模型实例保存前发送。
- `post_save`：在模型实例保存后发送。
- `pre_delete`：在模型实例删除前发送。
- `post_delete`：在模型实例删除后发送。
- `m2m_changed`：在模型实例的多对多关系改变时发送。

#### 请求/响应信号

- `request_started`：在请求处理开始时发送。
- `request_finished`：在请求处理结束时发送。
- `got_request_exception`：在请求处理过程中发生异常时发送。

#### 认证信号

- `user_logged_in`：在用户登录成功后发送。
- `user_logged_out`：在用户登出后发送。
- `user_login_failed`：在用户登录失败时发送。
- `password_changed`：在用户密码更改后发送。

#### 测试信号

- `setting_changed`：在设置改变时发送。
- `template_rendered`：在模板渲染后发送。

### 自定义信号

除了使用内置信号外，还可以创建自定义信号来处理应用程序特定的事件：

```python
from django.dispatch import Signal

# 创建自定义信号
payment_completed = Signal()  # 支付完成信号
order_shipped = Signal()  # 订单发货信号
```

### 连接信号

要处理信号，需要将接收者函数连接到信号：

```python
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.contrib.auth.models import User
from .models import Profile

# 使用装饰器连接信号
@receiver(post_save, sender=User)
def create_user_profile(sender, instance, created, **kwargs):
    """当用户创建时，自动创建用户资料"""
    if created:
        Profile.objects.create(user=instance)

# 使用connect方法连接信号
post_save.connect(create_user_profile, sender=User)
```

### 发送信号

内置信号由Django框架自动发送，而自定义信号需要手动发送：

```python
from .signals import payment_completed

def process_payment(payment):
    # 处理支付逻辑
    # ...
    
    # 发送支付完成信号
    payment_completed.send(
        sender=payment.__class__,
        payment=payment,
        amount=payment.amount,
        status=payment.status
    )
```

## 案例

### 用户资料自动创建

当新用户注册时，自动创建用户资料：

```python
# models.py
from django.db import models
from django.contrib.auth.models import User

class Profile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name="profile")
    bio = models.TextField(blank=True, verbose_name="个人简介")
    avatar = models.ImageField(upload_to="avatars/", blank=True, verbose_name="头像")
    birth_date = models.DateField(null=True, blank=True, verbose_name="出生日期")
    location = models.CharField(max_length=100, blank=True, verbose_name="所在地")
    website = models.URLField(blank=True, verbose_name="个人网站")
    created_at = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
    updated_at = models.DateTimeField(auto_now=True, verbose_name="更新时间")
    
    class Meta:
        verbose_name = "用户资料"
        verbose_name_plural = "用户资料"
    
    def __str__(self):
        return f"{self.user.username}的资料"

# signals.py
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.contrib.auth.models import User
from .models import Profile

@receiver(post_save, sender=User)
def create_user_profile(sender, instance, created, **kwargs):
    """当用户创建时，自动创建用户资料"""
    if created:
        Profile.objects.create(user=instance)

@receiver(post_save, sender=User)
def save_user_profile(sender, instance, **kwargs):
    """当用户更新时，自动更新用户资料"""
    instance.profile.save()

# apps.py
from django.apps import AppConfig

class UsersConfig(AppConfig):
    name = 'users'
    
    def ready(self):
        # 导入信号处理器
        import users.signals
```

### 文章浏览计数

当文章被访问时，自动增加浏览次数：

```python
# signals.py
from django.db.models.signals import post_save
from django.dispatch import receiver, Signal
from .models import Article, ArticleView

# 创建自定义信号
article_viewed = Signal()

@receiver(article_viewed)
def increment_article_views(sender, article, request, **kwargs):
    """当文章被查看时，增加浏览次数"""
    # 获取用户IP
    ip_address = get_client_ip(request)
    
    # 检查是否已经记录了此IP的浏览
    if not ArticleView.objects.filter(
        article=article,
        ip_address=ip_address,
        viewed_at__date=timezone.now().date()
    ).exists():
        # 创建浏览记录
        ArticleView.objects.create(
            article=article,
            ip_address=ip_address,
            user=request.user if request.user.is_authenticated else None
        )
        
        # 增加文章浏览次数
        article.views += 1
        article.save(update_fields=['views'])

def get_client_ip(request):
    x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
    if x_forwarded_for:
        ip = x_forwarded_for.split(',')[0]
    else:
        ip = request.META.get('REMOTE_ADDR')
    return ip

# views.py
from django.shortcuts import render, get_object_or_404
from .models import Article
from .signals import article_viewed

def article_detail(request, slug):
    article = get_object_or_404(Article, slug=slug, status='published')
    
    # 发送文章浏览信号
    article_viewed.send(
        sender=article.__class__,
        article=article,
        request=request
    )
    
    return render(request, 'blog/article_detail.html', {'article': article})

# models.py
from django.db import models
from django.contrib.auth.models import User

class Article(models.Model):
    # ...
    views = models.PositiveIntegerField(default=0, verbose_name="浏览次数")
    # ...

class ArticleView(models.Model):
    article = models.ForeignKey(Article, on_delete=models.CASCADE, related_name="article_views")
    user = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True)
    ip_address = models.GenericIPAddressField(verbose_name="IP地址")
    viewed_at = models.DateTimeField(auto_now_add=True, verbose_name="浏览时间")
    
    class Meta:
        verbose_name = "文章浏览"
        verbose_name_plural = "文章浏览"
        unique_together = ['article', 'ip_address', 'user']
```

### 订单处理流程

使用信号处理订单的各个状态变化：

```python
# signals.py
from django.dispatch import Signal

# 创建自定义信号
order_created = Signal()  # 订单创建信号
order_paid = Signal()  # 订单支付信号
order_shipped = Signal()  # 订单发货信号
order_delivered = Signal()  # 订单送达信号
order_cancelled = Signal()  # 订单取消信号

# models.py
from django.db import models
from django.contrib.auth.models import User

class Order(models.Model):
    STATUS_CHOICES = (
        ('pending', '待支付'),
        ('paid', '已支付'),
        ('shipped', '已发货'),
        ('delivered', '已送达'),
        ('cancelled', '已取消'),
    )
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name="orders")
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default="pending")
    total_amount = models.DecimalField(max_digits=10, decimal_places=2)
    shipping_address = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    def save(self, *args, **kwargs):
        # 检查状态是否改变
        if self.pk:
            old_status = Order.objects.get(pk=self.pk).status
            status_changed = old_status != self.status
        else:
            status_changed = False
            old_status = None
        
        # 保存订单
        super().save(*args, **kwargs)
        
        # 如果状态改变，发送相应的信号
        if status_changed:
            if self.status == 'paid' and old_status == 'pending':
                from .signals import order_paid
                order_paid.send(sender=self.__class__, order=self)
            elif self.status == 'shipped' and old_status == 'paid':
                from .signals import order_shipped
                order_shipped.send(sender=self.__class__, order=self)
            elif self.status == 'delivered' and old_status == 'shipped':
                from .signals import order_delivered
                order_delivered.send(sender=self.__class__, order=self)
            elif self.status == 'cancelled':
                from .signals import order_cancelled
                order_cancelled.send(sender=self.__class__, order=self)
        elif not self.pk:  # 新创建的订单
            from .signals import order_created
            order_created.send(sender=self.__class__, order=self)

# handlers.py
from django.dispatch import receiver
from django.core.mail import send_mail
from django.conf import settings
from .signals import order_created, order_paid, order_shipped, order_delivered, order_cancelled

@receiver(order_created)
def handle_order_created(sender, order, **kwargs):
    """处理订单创建事件"""
    # 发送订单确认邮件
    send_mail(
        subject="订单确认",
        message=f"您的订单 #{order.id} 已创建，请尽快支付。",
        from_email=settings.DEFAULT_FROM_EMAIL,
        recipient_list=[order.user.email],
    )
    
    # 记录订单日志
    OrderLog.objects.create(
        order=order,
        action="created",
        message="订单已创建"
    )

@receiver(order_paid)
def handle_order_paid(sender, order, **kwargs):
    """处理订单支付事件"""
    # 发送支付确认邮件
    send_mail(
        subject="支付确认",
        message=f"您的订单 #{order.id} 已支付成功，我们将尽快为您发货。",
        from_email=settings.DEFAULT_FROM_EMAIL,
        recipient_list=[order.user.email],
    )
    
    # 记录订单日志
    OrderLog.objects.create(
        order=order,
        action="paid",
        message="订单已支付"
    )
    
    # 通知仓库准备发货
    notify_warehouse(order)

@receiver(order_shipped)
def handle_order_shipped(sender, order, **kwargs):
    """处理订单发货事件"""
    # 发送发货通知邮件
    send_mail(
        subject="订单已发货",
        message=f"您的订单 #{order.id} 已发货，物流单号：{order.tracking_number}。",
        from_email=settings.DEFAULT_FROM_EMAIL,
        recipient_list=[order.user.email],
    )
    
    # 记录订单日志
    OrderLog.objects.create(
        order=order,
        action="shipped",
        message=f"订单已发货，物流单号：{order.tracking_number}"
    )

@receiver(order_delivered)
def handle_order_delivered(sender, order, **kwargs):
    """处理订单送达事件"""
    # 发送送达通知邮件
    send_mail(
        subject="订单已送达",
        message=f"您的订单 #{order.id} 已送达，感谢您的购买。",
        from_email=settings.DEFAULT_FROM_EMAIL,
        recipient_list=[order.user.email],
    )
    
    # 记录订单日志
    OrderLog.objects.create(
        order=order,
        action="delivered",
        message="订单已送达"
    )
    
    # 一周后发送评价提醒
    schedule_review_reminder(order)

@receiver(order_cancelled)
def handle_order_cancelled(sender, order, **kwargs):
    """处理订单取消事件"""
    # 发送取消通知邮件
    send_mail(
        subject="订单已取消",
        message=f"您的订单 #{order.id} 已取消。",
        from_email=settings.DEFAULT_FROM_EMAIL,
        recipient_list=[order.user.email],
    )
    
    # 记录订单日志
    OrderLog.objects.create(
        order=order,
        action="cancelled",
        message="订单已取消"
    )
    
    # 如果已支付，处理退款
    if order.is_paid:
        process_refund(order)
```

### 缓存失效

当模型数据更改时，自动使相关缓存失效：

```python
# signals.py
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from django.core.cache import cache
from .models import Article, Category

@receiver([post_save, post_delete], sender=Article)
def invalidate_article_cache(sender, instance, **kwargs):
    """当文章保存或删除时，使相关缓存失效"""
    # 清除文章详情缓存
    cache_key = f"article_{instance.pk}"
    cache.delete(cache_key)
    
    # 清除文章列表缓存
    cache.delete("article_list")
    
    # 清除分类文章列表缓存
    if instance.category:
        cache_key = f"category_{instance.category.pk}_articles"
        cache.delete(cache_key)
    
    # 清除标签文章列表缓存
    for tag in instance.tags.all():
        cache_key = f"tag_{tag.pk}_articles"
        cache.delete(cache_key)

@receiver([post_save, post_delete], sender=Category)
def invalidate_category_cache(sender, instance, **kwargs):
    """当分类保存或删除时，使相关缓存失效"""
    # 清除分类列表缓存
    cache.delete("category_list")
    
    # 清除分类详情缓存
    cache_key = f"category_{instance.pk}"
    cache.delete(cache_key)
    
    # 清除分类文章列表缓存
    cache_key = f"category_{instance.pk}_articles"
    cache.delete(cache_key)
```

### 审计日志

记录模型的所有变更：

```python
# models.py
from django.db import models
from django.contrib.auth.models import User
from django.contrib.contenttypes.fields import GenericForeignKey
from django.contrib.contenttypes.models import ContentType

class AuditLog(models.Model):
    ACTION_CHOICES = (
        ('create', '创建'),
        ('update', '更新'),
        ('delete', '删除'),
    )
    
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey('content_type', 'object_id')
    
    user = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True)
    action = models.CharField(max_length=10, choices=ACTION_CHOICES)
    changes = models.JSONField(default=dict)
    timestamp = models.DateTimeField(auto_now_add=True)
    ip_address = models.GenericIPAddressField(null=True, blank=True)
    
    class Meta:
        ordering = ['-timestamp']
        verbose_name = "审计日志"
        verbose_name_plural = "审计日志"
    
    def __str__(self):
        return f"{self.get_action_display()} {self.content_type} #{self.object_id}"

# signals.py
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from django.contrib.contenttypes.models import ContentType
from django.db import models
from .models import AuditLog

def get_request():
    """获取当前请求"""
    try:
        from threading import local
        _thread_locals = local()
        return getattr(_thread_locals, 'request', None)
    except:
        return None

@receiver(post_save)
def log_save(sender, instance, created, **kwargs):
    """记录模型保存事件"""
    # 排除一些不需要记录的模型
    if sender._meta.app_label in ['admin', 'sessions', 'contenttypes', 'auth'] or sender == AuditLog:
        return
    
    # 获取当前请求
    request = get_request()
    user = request.user if request and hasattr(request, 'user') else None
    ip_address = get_client_ip(request) if request else None
    
    # 获取变更内容
    if created:
        changes = {field.name: getattr(instance, field.name) for field in instance._meta.fields}
        action = 'create'
    else:
        if not hasattr(instance, '_original_state'):
            return
        
        changes = {}
        for field in instance._meta.fields:
            if field.name in instance._original_state:
                old_value = instance._original_state[field.name]
                new_value = getattr(instance, field.name)
                if old_value != new_value:
                    changes[field.name] = {'old': old_value, 'new': new_value}
        
        if not changes:  # 如果没有变更，不记录
            return
        
        action = 'update'
    
    # 创建审计日志
    content_type = ContentType.objects.get_for_model(instance)
    AuditLog.objects.create(
        content_type=content_type,
        object_id=instance.pk,
        user=user,
        action=action,
        changes=changes,
        ip_address=ip_address
    )

@receiver(post_delete)
def log_delete(sender, instance, **kwargs):
    """记录模型删除事件"""
    # 排除一些不需要记录的模型
    if sender._meta.app_label in ['admin', 'sessions', 'contenttypes', 'auth'] or sender == AuditLog:
        return
    
    # 获取当前请求
    request = get_request()
    user = request.user if request and hasattr(request, 'user') else None
    ip_address = get_client_ip(request) if request else None
    
    # 获取变更内容
    changes = {field.name: getattr(instance, field.name) for field in instance._meta.fields}
    
    # 创建审计日志
    content_type = ContentType.objects.get_for_model(instance)
    AuditLog.objects.create(
        content_type=content_type,
        object_id=instance.pk,
        user=user,
        action='delete',
        changes=changes,
        ip_address=ip_address
    )

# middleware.py
from threading import local

_thread_locals = local()

class RequestMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        # 将请求存储在线程本地变量中
        _thread_locals.request = request
        response = self.get_response(request)
        # 请求处理完毕后清除
        del _thread_locals.request
        return response

# models.py 中添加方法来保存原始状态
class BaseModel(models.Model):
    """基础模型，用于保存原始状态"""
    
    class Meta:
        abstract = True
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._original_state = self._get_current_state()
    
    def _get_current_state(self):
        return {field.name: getattr(self, field.name) for field in self._meta.fields}
    
    def save(self, *args, **kwargs):
        super().save(*args, **kwargs)
        self._original_state = self._get_current_state()
```

## 总结

1. **Django的信号系统提供了一种基于发布-订阅模式的事件通知机制**，允许在特定事件发生时发送通知，并由注册的接收者处理这些通知，实现组件间的松耦合。

2. **内置信号涵盖了常见的事件**，如模型的生命周期事件、请求/响应处理、用户认证等，减少了开发者的工作量。

3. **自定义信号可以处理应用程序特定的事件**，如订单状态变化、支付完成、文章浏览等，扩展了Django的功能。

4. **信号系统广泛应用于各种场景**，如用户资料自动创建、文章浏览计数、订单处理流程、缓存失效和审计日志等，提高了代码的可维护性和可扩展性。

5. **信号系统的优点是实现了组件间的松耦合**，发送者不需要知道接收者，接收者不需要知道发送者，使代码更加模块化和可维护。

通过本节课，我们深入了解了Django的信号系统，包括信号的概念、内置信号、自定义信号、连接信号和发送信号等核心概念。这些知识将帮助我们实现组件间的松耦合通信，构建更加模块化和可维护的Web应用程序。下一节将介绍Django的缓存系统，进一步探讨如何提高应用程序的性能和响应速度。