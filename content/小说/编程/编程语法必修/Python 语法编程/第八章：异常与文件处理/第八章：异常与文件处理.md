
---

### **<font color='OrangeRed'>第八章：异常与文件处理</font>**

嘿！编程路上难免磕磕碰碰，程序跑着跑着突然“挂了”？或者需要把数据存起来下次再用？

别担心，这一章咱们就来聊聊 Python 里怎么优雅地处理“意外”（异常）和跟“文件”打交道！

---

### **<font color='DeepSkyBlue'>一、异常：程序的小情绪</font>**

#### **<font color='DodgerBlue'>1. 什么是异常？</font>**

简单说，就是程序运行时发生的 **<font color='red'>错误或意外情况</font>**。

比如你想让程序除以零，或者打开一个不存在的文件，Python 就会“发脾气”，抛出个异常。

这可不是程序崩溃，而是它在告诉你：“<font color='red'><b>喂！这里有点不对劲！</b></font>”

#### **<font color='DodgerBlue'>2. 异常处理 (`try...except`)</font>**

遇到可能出错的代码，咱得有预案！

<font color='blue'><b>用 `try` 把它包起来。</b></font>

就像给它穿上“防弹衣”。

<font color='green'><b>`except` 语句块紧随其后，负责“接锅”。</b></font>

`try` 里的代码如果真的出错了，程序不会直接停下，而是跳到对应的 `except` 部分去执行。

```python
try:
  # 尝试做点可能有风险的事
  result = 10 / 0 # 呀！除以零了！
except ZeroDivisionError:
  # 出错了？淡定，执行这里的代码
  print("老铁，不能除以零啊！")
```

<font color='green'><b>看，程序没崩，还友好提示了！</b></font>

#### **<font color='DodgerBlue'>3. 抛出异常 (`raise`)</font>**

有时候，我们想 **<font color='orange'>主动</font>** 告诉大家：“我这里出问题了！”

比如检查用户输入，发现不合规矩，就可以自己“扔”一个异常出来。

<font color='blue'><b>用 `raise` 关键字，后面跟上你要抛出的异常类型（或者实例）。</b></font>

```python
def check_age(age):
  if age < 0:
    raise ValueError("年龄不能是负数啊，兄弟！") # 主动抛出！
  print(f"年龄合法：{age}")

# check_age(-5) # 这会触发 ValueError
```

#### **<font color='DodgerBlue'>4. 捕捉多个异常 (分开捕捉)</font>**

你的代码可能遇到 **<font color='purple'>不止一种</font>** 错误。

可以写 **<font color='purple'>多个 `except` 块</font>**，分别应对不同的异常类型。

```python
try:
  # 可能出各种错...
  # num = int("abc") # ValueError
  # result = my_list[10] # IndexError
except ValueError:
  print("输入的内容不是数字！")
except IndexError:
  print("列表下标越界了！")
```

<font color='green'><b>对症下药，分类处理！</b></font>

#### **<font color='DodgerBlue'>5. 使用一个块捕捉多个异常 (合并捕捉)</font>**

如果几种不同的异常，你都想用 **<font color='teal'>同一种方式</font>** 处理。

可以把它们放在一个 `except` 块里，用 **<font color='teal'>括号 `()` 包起来</font>**。

```python
try:
  # ... 可能出错的代码 ...
except (ValueError, TypeError, KeyError) as e:
  print(f"哎呀，出了点小状况（{type(e).__name__}）：{e}")
```

<font color='green'><b>省事儿！几个“亲戚”错误，一起招呼了！</b></font>

#### **<font color='DodgerBlue'>6. 捕捉对象 (`as e`)</font>**

想知道 **<font color='blue'>具体的错误信息</font>** 是啥？

在 `except` 后面跟上 `as` 和一个变量名（通常叫 `e` 或 `ex`）。

这个变量就会 **<font color='blue'>抓住那个“捣蛋鬼”（异常对象本身）</font>**。

```python
try:
  result = 1 / 0
except ZeroDivisionError as e:
  print(f"捕获到错误啦！信息是：【{e}】")
```

<font color='green'><b>拿到错误信息，方便调试或记录。</b></font>

#### **<font color='DodgerBlue'>7. 全捕捉</font>**

如果你想捕捉 **<font color='red'>所有可能</font>** 的异常。

可以用 `except Exception:` 或者干脆一个光秃秃的 `except:`。

**<font color='red'>但是！强烈不推荐！</font>**

这叫“<font color='red'><b>简单粗暴</b></font>”，容易把所有问题都掩盖掉，包括你没预料到的严重错误（比如 `SystemExit` 甚至是 `KeyboardInterrupt` Ctrl+C）。

**<font color='red'>知道可能出什么错，就精确捕捉什么错！</font>**

#### **<font color='DodgerBlue'>8. 异常中的 `else`</font>**

`try` 块后面，除了 `except`，还可以跟一个 `else` 块。

`else` 里的代码 **<font color='green'>只有在 `try` 块完全没出错</font>** 的情况下才会执行。

```python
try:
  result = 10 / 2 # 这次没问题
except ZeroDivisionError:
  print("除以零错误！")
else:
  print(f"计算成功！结果是：{result}") # try 没出错，这里会执行
```

<font color='green'><b>没出错？太好了，那就轮到我 `else` 上场了！</b></font>

#### **<font color='DodgerBlue'>9. 自定义异常</font>**

觉得 Python 自带的异常类型不够用？

**<font color='purple'>可以自己定义！</font>**

通常是创建一个类，让它 **<font color='purple'>继承自 `Exception`</font>** (或者某个更具体的异常类)。

```python
class MyCustomError(Exception): # 继承 Exception
  """我的专属错误类型"""
  pass

# 然后就可以像内置异常一样 raise 和 except 了
# raise MyCustomError("这是我自定义的错误信息！")
```

<font color='green'><b>打造你自己的专属“错误牌”，让错误信息更有针对性！</b></font>

#### **<font color='DodgerBlue'>10. `finally` 子句</font>**</h4>

`finally` 块里的代码，**<font color='blue'>无论如何</font>** 都会执行。

不管 `try` 里是否出错，也不管 `except` 是否捕捉到了异常，甚至你在 `try` 或 `except` 里 `return` 了。

**<font color='blue'>它都保证会被执行！</font>**

最常见的用途是 **<font color='red'>资源清理</font>**，比如关闭文件、释放锁等。

```python
f = None # 先声明
try:
  f = open("somefile.txt", "r")
  # ... 文件操作 ...
except FileNotFoundError:
  print("文件没找到...")
finally:
  if f: # 检查文件是否成功打开
    f.close() # 无论如何，尝试关闭文件
    print("文件已关闭 (finally)")
```

<font color='green'><b>“烂摊子”我 `finally` 来收拾，保证执行！</b></font>

#### **<font color='DodgerBlue'>11. 异常与函数</font>**

函数里如果发生异常，但函数内部没有 `try...except` 处理它。

那这个异常就会 **<font color='grey'>“冒泡”</font>** 出去，交给调用这个函数的地方去处理。

如果调用者也没处理，就继续往上冒，直到被某个 `try...except` 接住，或者最终导致程序终止。

<font color='grey'><b>函数里出错，会一层层往上“传递”，直到有人管或者程序崩掉。</b></font>

#### **<font color='DodgerBlue'>12. 异常链 (`raise from`)</font>**

有时候，你在处理一个异常时，想抛出另一个 **<font color='orange'>更有意义</font>** 的异常。

但又不想丢失 **<font color='orange'>原始的错误信息</font>**？

用 `raise NewException(...) from OriginalException`。

```python
def process_data(data):
  try:
    value = int(data)
  except ValueError as e:
    # 抛出新异常，但链接上原始的 ValueError
    raise TypeError("处理数据需要整数类型") from e

# process_data("abc")
```

这样报错时，会同时显示 `TypeError` 和导致它的 `ValueError`。

<font color='green'><b>“这锅是它（原始异常）甩给我的！”——保持错误根源，方便追踪问题！</b></font>

#### **<font color='DodgerBlue'>13. 上下文管理器与异常 (`with`)</font>**

还记得 `finally` 里手动关闭文件吗？有点麻烦。

**<font color='green'>`with` 语句是 Python 的一大神器！</font>**

它能自动管理资源（比如文件、网络连接、锁）。

**<font color='red'>它保证，无论 `with` 块内部发生什么（包括异常），资源都会被正确清理（比如文件自动关闭）。</font>**

```python
# 使用 with 打开文件，完全不需要手动 close()！
try:
  with open("myfile.txt", "w") as f:
    # ... 在这里写文件 ...
    # 就算这里出错了，文件也会被自动关闭！
    # data = 10 / 0 # 即使有这句，文件也会被关闭
    f.write("Hello with!\n")
except Exception as e:
    print(f"处理文件时发生错误: {e}")

# 文件在这里已经被自动关闭了，干净利落！
```

<font color='green'><b>`with` 语句：自动管理资源，异常安全的“贴心小棉袄”，强烈推荐！</b></font>

---

### **<font color='LimeGreen'>二、文件操作：与硬盘的亲密接触</font>**

程序运行完了，数据想保存下来？或者要读取配置文件？这就得和文件打交道了。

#### **<font color='SeaGreen'>1. 打开文件 (`open()`)</font>**</h4>

一切从 **<font color='blue'>`open()`</font>** 函数开始。

它需要至少一个参数：**<font color='blue'>文件名（路径）</font>**。

通常还需要第二个参数：**<font color='blue'>文件模式</font>**。

```python
# 最基本的样子
# f = open("my_notes.txt", "w") # 以写入模式打开
```

**<font color='red'>注意：打开了文件，用完了一定要记得关！(虽然我们更推荐用 `with`)</font>**

*   **文件模式 (mode)**：
    *   **<font color='green'>`'r'`</font>**: 读 (Read)。默认模式。文件不存在会报错。
    *   **<font color='green'>`'w'`</font>**: 写 (Write)。文件存在则清空，不存在则创建。
    *   **<font color='green'>`'a'`</font>**: 追加 (Append)。在文件末尾添加内容，不存在则创建。
    *   **<font color='green'>`'b'`</font>**: 二进制 (Binary) 模式。处理非文本文件（图片、视频等）。要和 `r`, `w`, `a` 组合，如 `'rb'`, `'wb'`.
    *   **<font color='green'>`'+'`</font>**: 读写模式。要和 `r`, `w`, `a` 组合，如 `'r+'`, `'w+'`, `'a+'`.
*   **缓存 (Buffering)**：
    *   <font color='grey'>操作系统为了效率，读写文件时会有缓存。</font>
    *   <font color='grey'>`write()` 不一定立刻写入硬盘，可能先放在内存里。</font>
    *   `close()` 会确保缓存内容写入硬盘。`with` 语句也能保证这点。

#### **<font color='SeaGreen'>2. 基本文件方法</font>**</h4>

拿到文件对象（`open()` 返回的东西，通常赋给变量 `f`）后，就可以操作了。

*   **读和写 (`read()`, `write()`)**
    *   **<font color='blue'>`f.read(size)`</font>**: 读取指定字节数（`size`）的内容。不给 `size` 就 **<font color='red'>全读</font>**（大文件慎用！）。
    *   **<font color='green'>`f.write(string)`</font>**: 把 `string` 写入文件。注意，只接受字符串（文本模式）或字节串（二进制模式）。返回写入的字符/字节数。

*   **读写行 (`readline()`, `readlines()`, `writelines()`)**
    *   **<font color='purple'>`f.readline()`</font>**: 读取 **<font color='purple'>一行</font>** 内容（包括行尾的 `\n`）。读到文件末尾返回空字符串。
    *   **<font color='purple'>`f.readlines()`</font>**: 读取 **<font color='red'>所有行</font>**，返回一个列表，每行是列表的一个元素。（大文件再次慎用！内存可能爆掉！）
    *   **<font color='purple'>`f.writelines(list_of_strings)`</font>**: 把一个 **<font color='purple'>字符串列表</font>** 中的所有字符串写入文件。**<font color='red'>注意：它不会自动添加换行符 `\n`！</font>** 需要你自己加在每个字符串末尾。

*   **关闭文件 (`close()`)**
    *   **<font color='red'>`f.close()`</font>**: 非常重要！释放文件资源，确保所有缓存数据写入硬盘。
    *   **<font color='red'>但强烈建议使用 `with open(...) as f:` 语句，它会自动帮你 `close()`！</font>**

*   **文件重命名 (`os.rename()`)**
    *   需要导入 `os` 模块：`import os`
    *   **<font color='orange'>`os.rename("old_name.txt", "new_name.txt")`</font>**

*   **删除文件 (`os.remove()`)**
    *   也需要 `import os`
    *   **<font color='orange'>`os.remove("file_to_delete.txt")`</font>**

#### **<font color='SeaGreen'>3. 对文件内容进行迭代</font>**</h4>

处理文件内容，不一定非要把整个文件读到内存里。

*   **按字节处理**
    *   用 `'rb'` (二进制读) 模式打开。
    *   用 `f.read(chunk_size)` 一块一块地读。适合处理大文件或二进制数据。

*   **按行操作 (最常用！)**
    *   **<font color='green'>文件对象本身就是个迭代器！</font>**
    *   可以直接用 `for` 循环遍历文件对象，每次迭代得到一行。
    *   **<font color='red'>这是处理文本文件最高效、最推荐的方式！</font>**

    ```python
    with open("my_log.txt", "r") as f:
      for line in f: # 每次读取一行，内存占用小
        print(line.strip()) # strip() 去掉首尾空白（包括换行符）
    ```

*   **使用 `fileinput` 实现懒加载式迭代**
    *   需要 `import fileinput`
    *   可以让你 **<font color='purple'>像处理一个文件一样，处理多个文件或者标准输入</font>**。
    *   也是 **<font color='purple'>懒加载</font>** 的，一行一行读，适合处理日志等。

    ```python
    import fileinput
    # 假设命令行运行 python script.py file1.txt file2.txt
    # for line in fileinput.input(): # 会依次读取 file1.txt 和 file2.txt 的内容
    #   process(line)
    ```

*   **文件迭代器**
    *   再次强调：**<font color='blue'>文件对象本身就是迭代器</font>**。`for line in f:` 就是利用了这个特性。

*   **`StringIO` 函数**
    *   需要 `from io import StringIO` (处理文本) 或 `BytesIO` (处理二进制)。
    *   让你 **<font color='orange'>在内存中创建一个“像文件一样”的对象</font>**。
    *   你可以像读写文件一样读写这个内存中的对象。
    *   非常适合 **<font color='orange'>测试</font>** 那些需要文件对象的函数，或者临时处理字符串数据。

    ```python
    from io import StringIO

    # 假装有个文件在内存里
    fake_file = StringIO("第一行\n第二行\n")
    print(fake_file.readline().strip()) # 输出: 第一行
    fake_file.write("这是新加的第三行\n")
    fake_file.seek(0) # 回到开头才能读全部
    print(fake_file.read())
    fake_file.close() # 虽然是内存对象，好习惯也要 close
    ```

#### **<font color='SeaGreen'>4. 序列化与反序列化</font>**</h4>

有时候，你想把 Python 里的对象（比如列表、字典、自定义类的实例）**<font color='blue'>存到文件里</font>**，或者 **<font color='blue'>通过网络发送</font>**。

这就需要 **<font color='red'>序列化 (Serialization)</font>**：把内存中的对象转换成一种可存储或传输的格式（如字符串、字节流）。

反过来，从这种格式恢复成内存中的对象，就是 **<font color='red'>反序列化 (Deserialization)</font>**。

*   **一般序列化与反序列化**
    *   这是一个 **<font color='blue'>通用概念</font>**，下面介绍几种具体实现方式。

*   **JSON 序列化与反序列化**
    *   **<font color='green'>JSON (JavaScript Object Notation)</font>** 是一种轻量级的数据交换格式。
    *   **<font color='red'>人类易读，机器易解析，通用性极强！</font>** Web API 常用。
    *   Python 内置 `json` 模块：
        *   **<font color='green'>`json.dumps(obj)`</font>**: (Dump String) 把 Python 对象 (字典、列表等) 序列化成 JSON **<font color='green'>字符串</font>**。
        *   **<font color='green'>`json.loads(json_string)`</font>**: (Load String) 把 JSON **<font color='green'>字符串</font>** 反序列化成 Python 对象。
        *   `json.dump(obj, fp)`: 把对象序列化成 JSON 格式写入 **<font color='green'>文件</font>** (`fp` 是文件对象)。
        *   `json.load(fp)`: 从 **<font color='green'>文件</font>** (`fp`) 读取 JSON 数据并反序列化。

    ```python
    import json
    my_dict = {"name": "小明", "age": 18, "skills": ["Python", "唱歌"]}

    # 序列化为 JSON 字符串
    json_str = json.dumps(my_dict, ensure_ascii=False, indent=4) # indent 美化输出
    print(json_str)

    # 反序列化回 Python 字典
    data_back = json.loads(json_str)
    print(data_back['skills'])
    ```

*   **二进制序列化 (`pickle`)**
    *   **<font color='purple'>`pickle` 是 Python 特有的</font>** 序列化模块。
    *   它可以序列化 **<font color='red'>几乎所有</font>** Python 对象（包括函数、类实例等），JSON 不行。
    *   序列化的结果是 **<font color='purple'>二进制</font>** 格式，人读不了，但通常比 JSON 更 **<font color='purple'>紧凑</font>**，对于纯 Python 环境可能 **<font color='purple'>更快</font>**。
    *   `pickle.dump(obj, fp)`: 把对象序列化后存入 **<font color='purple'>文件</font>** (需要以 `'wb'` 模式打开)。
    *   `pickle.load(fp)`: 从 **<font color='purple'>文件</font>** (需要以 `'rb'` 模式打开) 读取并反序列化。
    *   `pickle.dumps(obj)`: 序列化成 **<font color='purple'>字节串</font>**。
    *   `pickle.loads(bytes_obj)`: 从 **<font color='purple'>字节串</font>** 反序列化。
    *   **<font color='Red'>安全警告：绝对不要 `pickle.load()` 来自不信任来源的数据！</font>** 反序列化 pickle 数据可能执行任意代码，非常危险！

    ```python
    import pickle
    grades = {"Alice": 95, "Bob": 88}

    # 序列化到文件
    # with open("grades.pkl", "wb") as f:
    #   pickle.dump(grades, f)

    # 从文件反序列化
    # with open("grades.pkl", "rb") as f:
    #   loaded_grades = pickle.load(f)
    #   print(loaded_grades)
    ```

*   **XML 序列化与反序列化**
    *   **<font color='grey'>XML (eXtensible Markup Language)</font>** 是另一种常见的标记语言，常用于配置文件、数据交换（尤其在一些老系统或特定行业）。
    *   它比 JSON **<font color='grey'>结构更复杂，也更啰嗦</font>**。
    *   Python 有内置库如 **<font color='blue'>`xml.etree.ElementTree`</font>** 可以解析和创建 XML。
    *   将 Python 对象转为 XML 通常需要 **<font color='blue'>自己编写转换逻辑</font>**，或者使用第三方库。
    *   从 XML 解析回对象也类似，需要根据 XML 结构 **<font color='blue'>手动提取数据</font>** 并构建对象。
    *   **<font color='grey'>简单了解即可，除非特定场景需要，否则 JSON 通常更方便。</font>**

---

呼～ 这一章内容不少吧？异常处理让你的程序更“健壮”，文件操作让你能“持久化”数据。掌握了这些，你的 Python 技能又上了一个大台阶！特别是 **<font color='red'>`with` 语句</font>** 和 **<font color='red'>`for line in f`</font>**，一定要用起来！