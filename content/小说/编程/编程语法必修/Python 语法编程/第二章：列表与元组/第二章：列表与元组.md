---
title: "第二章：列表与元组"
slug: "第二章：列表与元组"
date: "2025-04-27T08:58:25.024946+00:00"
---

# 第二章：列表与元组

哈喽，各位小伙伴！上一章咱们跟 Python 混了个脸熟，是不是感觉还挺亲切的？

这章咱们来搞点更实用的东西：**列表 (List)** 和 **元组 (Tuple)**！

这俩兄弟可是 Python 里处理一堆数据的左膀右臂，超级重要！

## 通用序列操作 (Sequence Operations)

在正式认识列表和元组之前，咱们先来热个身，看看它们（以及字符串）都有哪些 **通用的骚操作**。

为啥叫“序列”呢？因为它们里面的元素都是 **排好队的**，有顺序的。

### 索引 (Indexing)

就像书有页码一样，序列里的每个元素都有自己的 **门牌号**，也就是 **索引**。

记住！Python 的索引是从 **0** 开始数的，不是 1 哦！

```python
my_list = ['苹果', '香蕉', '橘子']
my_tuple = ('猫', '狗', '兔子')
my_string = "Hello"

print(my_list[0])   # 输出 '苹果' (第一个元素)
print(my_tuple[1])  # 输出 '狗' (第二个元素)
print(my_string[-1]) # 输出 'o' (最后一个元素，负数表示倒着数)
```

想拿哪个，直接用方括号 `[]` 加上它的门牌号就行！**<font color='red'>是不是很简单粗暴？</font>**

### 分片 (Slicing)

有时候咱们不想要单个元素，而是想要 **一段连续的元素**，咋办？

用 **分片** 啊！就像切蛋糕一样，想切哪块切哪块！

语法是 `[start:end:step]`，记住是 **<font color='blue'>包头不包尾</font>**！

*   `start`：开始的索引（包含它）。不写默认从头开始。
*   `end`：结束的索引（**不包含它**）。不写默认到结尾。
*   `step`：步长，每次跳几个。不写默认是 1。

```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

print(numbers[2:5])   # 输出 [2, 3, 4] (从索引 2 到 5，不包括 5)
print(numbers[:3])    # 输出 [0, 1, 2] (从开头到 3，不包括 3)
print(numbers[6:])    # 输出 [6, 7, 8, 9] (从索引 6 到末尾)
print(numbers[::2])   # 输出 [0, 2, 4, 6, 8] (从头到尾，每隔一个取一个)
print(numbers[::-1])  # 输出 [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] (步长 -1，倒序)
```

**<font color='green'>切片大法好，想怎么切就怎么切！</font>**

### 序列相加 (+)

想把两个序列 **拼接** 在一起？用加号 `+` 就行了！

```python
list1 = [1, 2, 3]
list2 = [4, 5, 6]
result_list = list1 + list2
print(result_list) # 输出 [1, 2, 3, 4, 5, 6]

tuple1 = ('a', 'b')
tuple2 = ('c', 'd')
result_tuple = tuple1 + tuple2
print(result_tuple) # 输出 ('a', 'b', 'c', 'd')

str1 = "Hello"
str2 = " World"
result_str = str1 + str2
print(result_str) # 输出 "Hello World"
```

**<font color='orange'>注意：</font>** 只能是 **相同类型的序列** 才能相加哦！列表不能和元组加。

### 乘法 (*)

想把一个序列 **重复** 好几遍？用乘号 `*`！

```python
my_list = ['哈'] * 3
print(my_list) # 输出 ['哈', '哈', '哈']

my_tuple = (1, 2) * 2
print(my_tuple) # 输出 (1, 2, 1, 2)

my_string = "Abc" * 4
print(my_string) # 输出 "AbcAbcAbcAbc"
```

**<font color='purple'>魔性重复，就是这么简单！</font>**

### 成员资格 (in / not in)

想知道某个东西 **在不在** 这个序列里？用 `in` 或者 `not in` 来判断！

结果是布尔值 `True` (在) 或 `False` (不在)。

```python
fruits = ['apple', 'banana', 'orange']
print('banana' in fruits)     # 输出 True
print('grape' in fruits)      # 输出 False
print('apple' not in fruits)  # 输出 False

my_tuple = (10, 20, 30)
print(20 in my_tuple)         # 输出 True
print(40 not in my_tuple)     # 输出 True
```

**<font color='red'>查户口必备！</font>**

### 长度、最小值和最大值

这几个是内置函数，对所有序列都通用：

*   `len(sequence)`：获取序列的 **长度** (包含多少个元素)。
*   `min(sequence)`：获取序列里的 **最小值** (元素得能比较大小才行)。
*   `max(sequence)`：获取序列里的 **最大值** (元素得能比较大小才行)。

```python
numbers = [3, 1, 4, 1, 5, 9, 2]
letters = ('b', 'a', 'c', 'z')
text = "python"

print(len(numbers)) # 输出 7
print(len(letters)) # 输出 4
print(len(text))    # 输出 6

print(min(numbers)) # 输出 1
print(min(letters)) # 输出 'a'
print(min(text))    # 输出 'h' (按字母顺序)

print(max(numbers)) # 输出 9
print(max(letters)) # 输出 'z'
print(max(text))    # 输出 'y'
```

**<font color='blue'>这几个函数超常用，必须掌握！</font>**

## 列表 (List)

好了，热身完毕！现在正式请出咱们的主角之一：**列表 (List)**！

你可以把列表想象成一个 **可以随意修改的购物清单**。

*   用方括号 `[]` 定义。
*   里面的元素可以是 **任何类型** (数字、字符串、甚至其他列表都行)。
*   元素之间用逗号 `,` 隔开。
*   最最最重要的一点：列表是 **<font color='red'>可变的 (Mutable)</font>**！这意味着你可以随时 **增加、删除、修改** 里面的元素。

```python
# 创建一个空列表
empty_list = []

# 创建一个包含各种元素的列表
mixed_list = [1, "hello", 3.14, True, ["a", "b"]]

# 创建一个水果列表
fruits = ["苹果", "香蕉", "橘子"]
print(fruits)
```

### 更新列表

既然列表是可变的，那咱们就能对它动手动脚了！

#### 元素赋值

想把某个位置的元素换掉？直接用索引定位，然后用 `=` 赋新值！

```python
fruits = ["苹果", "香蕉", "橘子"]
print("修改前:", fruits)

fruits[1] = "芒果" # 把索引为 1 的 '香蕉' 换成 '芒果'
print("修改后:", fruits) # 输出 ['苹果', '芒果', '橘子']
```

**<font color='green'>指哪打哪，想换就换！</font>**

#### 增加元素

购物清单上想加点东西？没问题！

*   `append(item)`：在列表 **末尾** 添加一个元素。
    ```python
    fruits = ["苹果", "香蕉"]
    fruits.append("西瓜")
    print(fruits) # 输出 ['苹果', '香蕉', '西瓜']
    ```
*   `insert(index, item)`：在 **指定索引** 位置插入一个元素，后面的元素会自动往后挪。
    ```python
    fruits = ["苹果", "西瓜"]
    fruits.insert(1, "香蕉") # 在索引 1 的位置插入 '香蕉'
    print(fruits) # 输出 ['苹果', '香蕉', '西瓜']
    ```
*   `extend(another_list)`：把 **另一个列表** 的所有元素都追加到当前列表的末尾。
    ```python
    list1 = [1, 2]
    list2 = [3, 4]
    list1.extend(list2)
    print(list1) # 输出 [1, 2, 3, 4]
    # 注意和 + 的区别，extend 是在原地修改，+ 是生成新列表
    ```

**<font color='orange'>想加就加，队伍越来越壮大！</font>**

#### 删除元素

买完了或者不想要了？删掉！

*   `remove(item)`：删除列表中 **第一个** 出现的指定元素。如果元素不存在，会报错！
    ```python
    pets = ['猫', '狗', '兔子', '狗']
    pets.remove('狗') # 只会删除第一个 '狗'
    print(pets) # 输出 ['猫', '兔子', '狗']
    ```
*   `pop(index=-1)`：删除 **指定索引** 的元素，并 **返回** 被删除的元素。如果不指定索引，默认删除 **最后一个** 元素。
    ```python
    numbers = [10, 20, 30, 40]
    last_num = numbers.pop() # 删除并返回最后一个元素
    print("删除的元素:", last_num) # 输出 40
    print("剩余列表:", numbers)   # 输出 [10, 20, 30]

    second_num = numbers.pop(1) # 删除并返回索引为 1 的元素
    print("删除的元素:", second_num) # 输出 20
    print("剩余列表:", numbers)    # 输出 [10, 30]
    ```
*   `del list_name[index]`：用 `del` 关键字删除指定索引的元素。
    ```python
    letters = ['a', 'b', 'c', 'd']
    del letters[0]
    print(letters) # 输出 ['b', 'c', 'd']
    ```
*   `clear()`：清空整个列表，变成一个空列表。
    ```python
    items = [1, 2, 3]
    items.clear()
    print(items) # 输出 []
    ```

**<font color='purple'>断舍离，说删就删！</font>**

#### 分片赋值

这个更牛！可以直接用 **切片** 来 **替换、删除或插入** 一段元素！

```python
numbers = [1, 2, 3, 4, 5]

# 替换一段
numbers[1:4] = [9, 8, 7] # 把索引 1 到 3 的元素替换掉
print(numbers) # 输出 [1, 9, 8, 7, 5]

# 替换长度可以不一样
numbers[1:3] = [100, 200, 300, 400] # 用 4 个元素替换原来的 2 个
print(numbers) # 输出 [1, 100, 200, 300, 400, 7, 5]

# 删除一段
numbers[2:5] = [] # 把索引 2 到 4 的元素删掉
print(numbers) # 输出 [1, 100, 7, 5]

# 插入一段 (切片范围的 start 和 end 一样)
numbers[1:1] = [10, 20] # 在索引 1 的位置插入
print(numbers) # 输出 [1, 10, 20, 100, 7, 5]
```

**<font color='red'>分片赋值，批量操作，效率杠杠的！</font>**

### 嵌套列表 (Nested Lists)

列表里面还能放列表！这就叫 **嵌套列表**，可以用来表示二维数组或者更复杂的数据结构。

```python
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

print(matrix[0])    # 输出第一行 [1, 2, 3]
print(matrix[1][1]) # 输出第二行第二个元素 5

# 修改嵌套列表的元素
matrix[2][0] = 777
print(matrix) # 输出 [[1, 2, 3], [4, 5, 6], [777, 8, 9]]
```

**<font color='blue'>一层套一层，俄罗斯套娃既视感！</font>**

### 列表方法 (List Methods)

除了上面介绍的增删改，列表还有很多 **内置的方法** (可以理解为列表自带的特殊功能)，超级好用！

*   `count(item)`：统计某个元素在列表中出现了 **多少次**。
    ```python
    numbers = [1, 2, 2, 3, 2, 4]
    print(numbers.count(2)) # 输出 3
    ```
*   `index(item, start=0, end=len(list))`：查找某个元素 **第一次** 出现的 **索引**。可以指定查找范围。如果找不到会报错！
    ```python
    letters = ['a', 'b', 'c', 'b', 'd']
    print(letters.index('b')) # 输出 1 (第一个 'b' 的索引)
    print(letters.index('b', 2)) # 输出 3 (从索引 2 开始找 'b')
    ```
*   `reverse()`：**原地** 将列表中的元素 **反转**。
    ```python
    nums = [1, 2, 3, 4]
    nums.reverse()
    print(nums) # 输出 [4, 3, 2, 1]
    ```
*   `sort(key=None, reverse=False)`：**原地** 对列表进行 **排序**。默认升序。
    *   `key`：可以指定一个函数，用来自定义排序规则。
    *   `reverse=True`：表示降序排序。
    ```python
    numbers = [3, 1, 4, 1, 5, 9]
    numbers.sort() # 默认升序
    print(numbers) # 输出 [1, 1, 3, 4, 5, 9]

    numbers.sort(reverse=True) # 降序
    print(numbers) # 输出 [9, 5, 4, 3, 1, 1]

    words = ["apple", "Banana", "Cherry"]
    words.sort(key=str.lower) # 按小写字母排序
    print(words) # 输出 ['apple', 'Banana', 'Cherry']
    ```
*   `copy()`：创建列表的一个 **浅拷贝 (shallow copy)**。啥意思？就是创建一个 **新的列表**，里面的元素和原来的一样。但如果元素本身是可变对象（比如列表），那么新旧列表里的这个元素还是指向 **同一个对象**。
    ```python
    old_list = [1, 2, ['a', 'b']]
    new_list = old_list.copy()

    new_list[0] = 100
    new_list[2].append('c')

    print("Old list:", old_list) # 输出 [1, 2, ['a', 'b', 'c']]
    print("New list:", new_list) # 输出 [100, 2, ['a', 'b', 'c']]
    # 注意：修改 new_list 的第一层元素不影响 old_list，
    # 但修改嵌套列表的内容，两者都会变！
    ```

**<font color='green'>这么多方法，列表简直是万能工具箱！</font>**

## 元组 (Tuple)

说完灵活多变的列表，咱们来看看它的“好兄弟”—— **元组 (Tuple)**。

你可以把元组想象成一个 **用胶水粘死了的购物清单**。

*   用 **小括号 `()`** 定义 (其实括号不是必须的，主要是里面的逗号 `,`)。
*   里面的元素也可以是 **任何类型**。
*   元素之间用逗号 `,` 隔开。
*   最最最重要的一点：元组是 **<font color='red'>不可变的 (Immutable)</font>**！一旦创建，你就 **不能修改** 里面的元素了！不能增加、不能删除、不能替换！

```python
# 创建一个空元组
empty_tuple = ()

# 创建一个包含单个元素的元组 (注意末尾必须有逗号！)
single_tuple = (1,)

# 创建一个包含多个元素的元组
my_tuple = (1, "hello", 3.14, True)
print(my_tuple)

# 其实括号可以省略 (但不推荐，容易混淆)
another_tuple = 10, 20, 30
print(another_tuple)
```

### tuple 函数

可以用 `tuple()` 函数把其他 **可迭代对象** (比如列表、字符串) 转换成元组。

```python
my_list = [1, 2, 3]
tuple_from_list = tuple(my_list)
print(tuple_from_list) # 输出 (1, 2, 3)

my_string = "abc"
tuple_from_string = tuple(my_string)
print(tuple_from_string) # 输出 ('a', 'b', 'c')
```

### 元组的基本操作

之前介绍的 **通用序列操作**，元组 **大部分都支持**！

*   **索引**：`my_tuple[0]`
*   **分片**：`my_tuple[1:3]`
*   **相加**：`tuple1 + tuple2`
*   **乘法**：`my_tuple * 3`
*   **成员资格**：`item in my_tuple`
*   **长度、最小值、最大值**：`len()`, `min()`, `max()`

```python
point = (10, 20)
print(point[0]) # 10

colors = ('red', 'green', 'blue')
print(colors[1:]) # ('green', 'blue')

combined = point + colors
print(combined) # (10, 20, 'red', 'green', 'blue')

repeated = ('Go',) * 3
print(repeated) # ('Go', 'Go', 'Go')

print('red' in colors) # True

print(len(colors)) # 3
```

**<font color='orange'>通用操作，元组也能玩！</font>**

### 访问元组

跟列表一样，用 **索引** 和 **分片** 来访问。

```python
my_tuple = ('P', 'y', 't', 'h', 'o', 'n')
print(my_tuple[2])   # 输出 't'
print(my_tuple[-1])  # 输出 'n'
print(my_tuple[1:4]) # 输出 ('y', 't', 'h')
```

### 修改元组

**<font color='red'>划重点：元组是不可变的！你不能修改它！</font>**

下面的操作都会 **报错**：

```python
my_tuple = (1, 2, 3)
# my_tuple[0] = 100 # TypeError: 'tuple' object does not support item assignment
# my_tuple.append(4) # AttributeError: 'tuple' object has no attribute 'append'
# del my_tuple[0]   # TypeError: 'tuple' object doesn't support item deletion
```

**那如果我实在想改怎么办？**

只能 **创建一个新的元组** 来代替旧的。

```python
old_tuple = (1, 2, 3)
new_tuple = old_tuple[:1] + (100,) + old_tuple[2:] # 通过拼接创建新元组
print(new_tuple) # 输出 (1, 100, 3)
```

或者，先把元组 **转成列表**，修改完再 **转回元组**。

```python
my_tuple = (10, 20, 30)
temp_list = list(my_tuple)
temp_list[1] = 200
my_tuple = tuple(temp_list)
print(my_tuple) # 输出 (10, 200, 30)
```

**<font color='purple'>虽然不能直接改，但总有曲线救国的办法！</font>**

### 删除元组

你 **不能删除元组中的某个元素**，但可以用 `del` 关键字 **删除整个元组变量**。

```python
my_tuple = (1, 2, 3)
del my_tuple
# print(my_tuple) # NameError: name 'my_tuple' is not defined (因为已经被删了)
```

### 元组索引、截取

这部分跟列表的索引和分片 **完全一样**，参考前面的内容就好啦。

### 元组内置函数

元组因为是不可变的，所以它的内置方法比列表少得多，只有两个比较常用的：

*   `count(item)`：统计某个元素在元组中出现了 **多少次**。
*   `index(item, start=0, end=len(tuple))`：查找某个元素 **第一次** 出现的 **索引**。

```python
numbers = (1, 2, 2, 3, 2, 4, 2)
print(numbers.count(2)) # 输出 4

letters = ('a', 'b', 'c', 'b', 'd')
print(letters.index('b')) # 输出 1
```

**<font color='blue'>方法虽少，但够用就行！</font>**

## 列表与元组的区别 (List vs Tuple)

好了，学完了列表和元组，咱们来总结一下它俩的 **核心区别**：

| 特性       | 列表 (List)                     | 元组 (Tuple)                       |
| :--------- | :------------------------------ | :--------------------------------- |
| **定义**   | 方括号 `[]`                     | 小括号 `()` (或省略)              |
| **可变性** | **<font color='red'>可变 (Mutable)</font>** | **<font color='red'>不可变 (Immutable)</font>** |
| **修改**   | 可以增、删、改元素              | **不能** 修改元素                  |
| **方法**   | 方法多 (append, insert, remove等) | 方法少 (只有 count, index)         |
| **性能**   | 相对元组稍慢，占用内存稍多      | 相对列表稍快，占用内存稍少         |
| **用途**   | 需要经常修改的数据集合          | 不希望被修改的数据集合，用作字典键 |

**简单来说：**

*   想随时改动？用 **列表**！
*   数据不让别人乱动？或者想让程序跑得快一点点？用 **元组**！
*   想把数据当成字典的 key？只能用 **元组** (因为 key 必须是不可变的)！

## 列表与元组的相互转化

有时候，你可能需要在列表和元组之间反复横跳，咋办？

用 `list()` 和 `tuple()` 函数啊！

*   `list(my_tuple)`：把元组变成列表。
*   `tuple(my_list)`：把列表变成元组。

```python
my_tuple = (1, 2, 3)
converted_list = list(my_tuple)
print(converted_list) # 输出 [1, 2, 3]
converted_list.append(4)
print(converted_list) # 输出 [1, 2, 3, 4]

my_list = ['a', 'b', 'c']
converted_tuple = tuple(my_list)
print(converted_tuple) # 输出 ('a', 'b', 'c')
# converted_tuple[0] = 'A' # 报错！元组不可变
```

**<font color='green'>想变就变，就是这么灵活！</font>**

好啦，关于列表和元组的探险就到这里！这两个家伙是 Python 里处理数据的基础，一定要多练练，把它们玩熟！下一章咱们去探索更神奇的数据结构！