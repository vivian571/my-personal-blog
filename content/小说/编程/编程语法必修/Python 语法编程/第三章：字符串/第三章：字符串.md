---
title: "第三章：字符串"
slug: "第三章：字符串"
date: "2025-04-27T08:58:25.021928+00:00"
---

# 第三章：字符串——玩转文字的艺术

嘿，小伙伴们！上一章咱们把列表和元组这两个“数据收纳盒”给整明白了，是不是感觉 Python 越来越像个贴心小棉袄了？

别急，这章咱们来聊聊另一个超级常用的家伙——**字符串 (String)**！

这玩意儿，说白了就是 **一串文字**。

无论是你的名字、一篇文章，还是一句代码里的提示，背后都是字符串在撑腰！

准备好了吗？系好安全带，咱们一起去字符串的世界里飙车！

## 字符串是什么？如何创建？

简单粗暴地说，被 **单引号 `' '`**、**双引号 `" "`** 或者 **三引号 `''' '''` 或 `""" """`** 包起来的，就是字符串！

```python
name = '钢铁侠'
message = "I am Iron Man!"
long_text = '''
这是第一行，
这是第二行，
可以写好多好多行。
'''

print(name)
print(message)
print(long_text)
```

**<font color='red'>重点来了：</font>** 单引号和双引号没啥本质区别，看你心情用哪个。

但如果你的字符串里面本身就包含单引号，那外面最好用双引号，反之亦然，避免打架！

```python
# 错误示范，Python 会懵逼
# bad_str = 'I\'m Iron Man!'

# 正确姿势
good_str1 = "I'm Iron Man!" # 外双内单
good_str2 = '他说："你好！"' # 外单内双
```

三引号（三个单引号或三个双引号）就更牛了，它可以让你写 **跨行的字符串**，里面写啥都行，引号随便用，简直是自由飞翔！

## 字符串的基本操作（与序列操作类似）

还记得上一章咱们学的序列通用操作吗？索引、切片、加号、乘号那些？

恭喜你！字符串作为序列的一种，这些操作 **<font color='blue'>大部分都支持</font>**！

### 索引 (Indexing) - 定位到特定字符

跟列表元组一样，字符串里的每个字符也有自己的门牌号（索引），从 **0** 开始。

```python
hero = "Python"

print(hero[0])  # 输出 'P' (第一个字符)
print(hero[2])  # 输出 't' (第三个字符)
print(hero[-1]) # 输出 'n' (最后一个字符)
```

**<font color='green'>想取哪个字，直接上索引！</font>**

### 切片 (Slicing) - 截取子字符串

想截取字符串的一部分？切片大法再次登场！`[start:end:step]`，**<font color='blue'>包头不包尾</font>** 的规矩别忘了！

```python
text = "Hello, World!"

print(text[0:5])  # 输出 'Hello' (从索引 0 到 5，不包括 5)
print(text[7:])   # 输出 'World!' (从索引 7 到末尾)
print(text[:5])   # 输出 'Hello' (从开头到 5，不包括 5)
print(text[::2])  # 输出 'Hlo ol!' (隔一个取一个)
print(text[::-1]) # 输出 '!dlroW ,olleH' (倒序字符串)
```

**<font color='orange'>想切哪段切哪段，灵活得一批！</font>**

### 序列相加 (+) - 拼接字符串

用加号 `+` 可以把两个字符串粘在一起。

```python
str1 = "学好 Python，"
str2 = "走遍天下都不怕！"
result = str1 + str2
print(result) # 输出 '学好 Python，走遍天下都不怕！'
```

**<font color='purple'>字符串拼接，就用加号！</font>**

### 乘法 (*) - 重复字符串

想让一个字符串重复出现好几次？用乘号 `*`。

```python
word = "酷" * 5
print(word) # 输出 '酷酷酷酷酷'
```

**<font color='red'>重要的事情说三遍？不，说五遍！</font>**

### 成员资格 (in / not in) - 检查子串是否存在

想知道某个字或某段话在不在一个字符串里？用 `in` 或 `not in`。

```python
sentence = "Python is fun!"

print('fun' in sentence)     # 输出 True
print('easy' in sentence)    # 输出 False
print('Python' not in sentence) # 输出 False
```

**<font color='blue'>查找指定内容，`in` 你值得拥有！</font>**

### 长度、最小值和最大值 (len, min, max)

这几个老朋友也适用于字符串：

*   `len(string)`：字符串包含多少个 **字符**。
*   `min(string)`：字符串里 **最小** 的字符（按 ASCII 或 Unicode 编码顺序）。
*   `max(string)`：字符串里 **最大** 的字符。

```python
my_str = "abcABC123"

print(len(my_str)) # 输出 9
print(min(my_str)) # 输出 '1' (数字比大写字母小)
print(max(my_str)) # 输出 'c' (小写字母比大写字母和数字都大)
```

**<font color='green'>基本信息查询，这仨函数搞定！</font>**

**<font color='red'>注意：</font>** 字符串和列表/元组最大的不同在于，字符串是 **<font color='red'>不可变的 (Immutable)</font>**！

这意味着你 **不能** 像修改列表那样，直接通过索引去修改字符串里的某个字符！

```python
my_string = "Hello"
# my_string[0] = 'J' # 这行会报错! TypeError: 'str' object does not support item assignment
```

想改？只能创建一个 **新的字符串**。

```python
my_string = "Hello"
new_string = 'J' + my_string[1:] # 通过拼接创建新字符串
print(new_string) # 输出 'Jello'
```

## 字符串格式化 - 让输出更美观

有时候，咱们想把变量的值塞到字符串里输出，比如 "你好，XXX！欢迎来到 Python 世界！"。

直接用加号拼？太 low 了，而且麻烦！

Python 提供了几种更优雅的方式来 **格式化字符串**。

### 方法一：百分号 `%` （传统但常用）

这是 C 语言留下来的老传统，用 `%` 作为占位符。

*   `%s`：字符串 (啥都能转成字符串塞进来)
*   `%d`：整数
*   `%f`：浮点数 (小数)

```python
name = "Alice"
age = 18
height = 1.65

# 使用 % 格式化
print("姓名：%s" % name)
print("年龄：%d" % age)
print("身高：%.2f 米" % height) # %.2f 表示保留两位小数

# 使用 % 格式化元组 (多个值)
print("大家好，我叫 %s，今年 %d 岁，身高 %.2f 米。" % (name, age, height))
```

**<font color='orange'>老方法，简单直接，但可读性稍差。</font>**

还有一些 **转换操作符** 可以加在 `%` 后面，控制输出格式：

*   `%c`: 单个字符
*   `%o`: 八进制整数
*   `%x`: 十六进制整数 (小写)
*   `%X`: 十六进制整数 (大写)
*   `%e`: 科学计数法 (小写 'e')
*   `%E`: 科学计数法 (大写 'E')
*   `%g`: 根据值自动选择 %f 或 %e
*   `%G`: 根据值自动选择 %f 或 %E

```python
num = 65
print("字符：%c" % num) # 输出 'A' (ASCII 65 对应 'A')
print("八进制：%o" % 10) # 输出 12
print("十六进制：%x" % 255) # 输出 ff
```

### 方法二：`str.format()` 方法（更灵活）

这个方法用花括号 `{}` 做占位符，更灵活强大。

```python
name = "Bob"
age = 25

# 按顺序填充
print("我是 {}，今年 {} 岁。".format(name, age))

# 按索引填充
print("我是 {0}，{0} 今年 {1} 岁。".format(name, age))

# 按名称填充
print("我是 {n}，今年 {a} 岁。".format(n=name, a=age))

# 混合使用 + 格式控制
pi = 3.1415926
print("圆周率约等于 {:.3f}".format(pi)) # 输出 3.142
```

**<font color='purple'>`.format()` 功能更全，推荐使用！</font>**

### 方法三：f-strings (Python 3.6+，强烈推荐！)

这是目前 **<font color='red'>最简洁、最直观、最高效</font>** 的方式！

在字符串前面加个 `f`，然后直接在花括号 `{}` 里写变量名或表达式！

```python
name = "Charlie"
age = 30
score = 95.5

print(f"学生姓名：{name}")
print(f"年龄：{age}")
print(f"他的分数是：{score}")
print(f"{name} 明年就 {age + 1} 岁了！")
print(f"成绩保留一位小数：{score:.1f}") # 输出 95.5
```

**<font color='green'>f-strings，YYDS (永远的神)！写起来爽，看起来也爽！</font>**

## 字符串方法 - 内置函数大全

字符串作为 Python 的“亲儿子”，自带了很多 **内置方法**，让处理文本变得超级简单！就像给字符串配了一套瑞士军刀！

记住：字符串是不可变的，所以这些方法 **<font color='blue'>都不会修改原始字符串</font>**，而是 **<font color='blue'>返回一个新的字符串</font>**！

### `find(sub, start=0, end=len(string))` - 查找子串位置

查找 `sub` 这个子字符串在原字符串中 **第一次** 出现的位置（索引）。

可以指定查找范围 `[start, end)`。

如果 **找不到**，它不会报错，而是 **<font color='red'>返回 -1</font>**。

```python
text = "hello world, hello python"

print(text.find('hello'))      # 输出 0 (第一个 hello 在索引 0)
print(text.find('hello', 1))   # 输出 13 (从索引 1 开始找，找到第二个 hello)
print(text.find('java'))       # 输出 -1 (找不到)
```

**<font color='orange'>`find` 找不到不报错，返回 -1，很温柔。</font>** (还有一个类似的 `index()` 方法，找不到会直接报错，比较暴躁)

### `join(iterable)` - 使用字符串连接序列

这个方法有点特别，它是用 **调用它的那个字符串** 作为 **分隔符**，把一个 **可迭代对象** (比如列表、元组) 里的所有 **字符串元素** 连接成一个新的字符串。

```python
my_list = ['apple', 'banana', 'orange']
separator = ', '

result = separator.join(my_list)
print(result) # 输出 'apple, banana, orange'

separator2 = '-'
my_tuple = ('2023', '10', '26') # 元组元素必须是字符串
result2 = separator2.join(my_tuple)
print(result2) # 输出 '2023-10-26'
```

**<font color='purple'>`join` 是 `split` 的逆操作，超级实用！</font>**

### `lower()` / `upper()` / `swapcase()` - 大小写转换

*   `lower()`：把所有大写字母变成 **小写**。
*   `upper()`：把所有小写字母变成 **大写**。
*   `swapcase()`：**大小写互换**。

```python
text = "Hello, Python!"

print(text.lower())    # 输出 'hello, python!'
print(text.upper())    # 输出 'HELLO, PYTHON!'
print(text.swapcase()) # 输出 'hELLO, pYTHON!'
```

**<font color='red'>处理大小写不敏感的场景，必备！</font>**

### `replace(old, new, count=-1)` - 替换子串

把字符串中的 `old` 子串替换成 `new` 子串。

默认替换 **所有** 出现的 `old`。

可以指定 `count` 参数，只替换 **前 `count` 个**。

```python
text = "I like Python. Python is cool."

new_text1 = text.replace('Python', 'Java')
print(new_text1) # 输出 'I like Java. Java is cool.' (替换所有)

new_text2 = text.replace('Python', 'Java', 1)
print(new_text2) # 输出 'I like Java. Python is cool.' (只替换第一个)
```

**<font color='blue'>查找替换，`replace` 搞定！</font>**

### `split(sep=None, maxsplit=-1)` - 分割字符串

把一个字符串按照 **分隔符 `sep`** 切割成一个 **列表 (List)**。

*   如果不指定 `sep` (或者 `sep=None`)，默认会以 **空白字符** (空格、换行 `\n`、制表符 `\t` 等) 作为分隔符，并且会自动忽略连续的空白。
*   可以指定 `maxsplit` 参数，表示最多切割几次。

```python
text1 = "apple banana orange"
words1 = text1.split() # 默认按空白分割
print(words1) # 输出 ['apple', 'banana', 'orange']

text2 = "one,two,three"
words2 = text2.split(',') # 按逗号分割
print(words2) # 输出 ['one', 'two', 'three']

text3 = "a b c d"
words3 = text3.split(' ', 1) # 最多分割 1 次
print(words3) # 输出 ['a', 'b c d']
```

**<font color='green'>处理有规律的文本数据，`split` 是大杀器！</font>**

### `strip([chars])` / `lstrip([chars])` / `rstrip([chars])` - 去除首尾字符

*   `strip()`：去除字符串 **首尾** 指定的字符（默认是空白字符）。
*   `lstrip()`：只去除 **开头** 的指定字符。
*   `rstrip()`：只去除 **末尾** 的指定字符。

`chars` 参数是一个字符串，里面包含 **所有** 要去除的字符。

```python
text1 = "   hello world   "
print(f"'{text1.strip()}'")   # 输出 ''hello world'' (去除首尾空格)
print(f"'{text1.lstrip()}'")  # 输出 ''hello world   '' (去除开头空格)
print(f"'{text1.rstrip()}'")  # 输出 ''   hello world'' (去除末尾空格)

text2 = "***abc***xyz***"
print(text2.strip('*'))   # 输出 'abc***xyz' (去除首尾的星号)
print(text2.strip('*xyz')) # 输出 'abc' (去除首尾的 *, x, y, z 任意组合)
```

**<font color='orange'>清理用户输入或者处理文件数据时，经常用到！</font>**

### `translate(table)` - 字符映射转换（进阶）

这个稍微复杂点，它可以根据一个 **映射表 (table)** 来替换字符串中的字符。

这个映射表通常用 `str.maketrans(fromstr, tostr, deletestr)` 来创建：

*   `fromstr`: 要被替换的字符组成的字符串。
*   `tostr`: 替换后的字符组成的字符串 (必须和 `fromstr` 等长)。
*   `deletestr`: 要删除的字符组成的字符串。

```python
# 场景：把 'aeiou' 替换成 '12345'，并删除空格
text = "hello world, this is a test."

# 创建映射表
intab = "aeiou"
outtab = "12345"
delchar = " "
trans_table = str.maketrans(intab, outtab, delchar)

# 应用转换
translated_text = text.translate(trans_table)
print(translated_text) # 输出 'h2ll4w4rld,th3s3s1t2st.'
```

**<font color='purple'>`translate` 适合做批量、复杂的字符替换或删除。</font>**

## 字符串的编码与解码 - 与计算机沟通的语言

咱们看到的文字，计算机内部其实是用 **数字** 来表示的。

这个 **文字 <-> 数字** 的转换规则，就是 **编码 (Encoding)**。

常见的编码有：

*   **ASCII**: 最早的美国标准，只能表示英文字母、数字和一些符号，存一个字符用 1 个字节。
*   **GBK / GB2312**: 中国标准，用来表示汉字，兼容 ASCII。GBK 范围更大。
*   **UTF-8**: **<font color='red'>万国码！</font>** 目前最通用、最推荐的编码！它可以表示世界上几乎所有的文字，而且兼容 ASCII。它是一种 **可变长度** 的编码，英文字符用 1 个字节，常用汉字用 3 个字节。

**为啥要懂编码？**

因为不同编码规则下，同一个汉字对应的数字可能不一样！如果你用 GBK 的规则去读一个 UTF-8 编码的文件，或者反过来，就会出现 **<font color='red'>乱码</font>**！

Python 3 默认使用 **UTF-8** 编码，这大大减少了乱码问题，但有时处理文件或网络数据，还是需要手动指定编码。

### `encode(encoding='utf-8', errors='strict')` - 编码

把 **字符串 (str)** 按照指定的 `encoding` 转换成 **字节串 (bytes)**。

`errors` 参数指定遇到无法编码的字符时怎么办 (默认 `strict` 是报错)。

```python
text = "你好，Python！"

# 编码成 UTF-8 字节串
utf8_bytes = text.encode('utf-8')
print(utf8_bytes) # 输出 b'\xe4\xbd\xa0\xe5\xa5\xbd\xef\xbc\x8cPython\xef\xbc\x81'

# 编码成 GBK 字节串
gbk_bytes = text.encode('gbk')
print(gbk_bytes)  # 输出 b'\xc4\xe3\xba\xc3\xa3\xacPython\xa3\xa1'

print(type(utf8_bytes)) # 输出 <class 'bytes'>
```

**<font color='blue'>`encode()`：字符串 -> 字节串 (给计算机看的)</font>**

### `decode(encoding='utf-8', errors='strict')` - 解码

把 **字节串 (bytes)** 按照指定的 `encoding` 转换回 **字符串 (str)**。

**<font color='red'>解码时用的编码，必须和当初编码时用的编码一致，否则就会乱码！</font>**

```python
utf8_bytes = b'\xe4\xbd\xa0\xe5\xa5\xbd\xef\xbc\x8cPython\xef\xbc\x81'
gbk_bytes = b'\xc4\xe3\xba\xc3\xa3\xacPython\xa3\xa1'

# 用 UTF-8 解码 UTF-8 字节串 (正确)
text1 = utf8_bytes.decode('utf-8')
print(text1) # 输出 '你好，Python！'

# 用 GBK 解码 GBK 字节串 (正确)
text2 = gbk_bytes.decode('gbk')
print(text2) # 输出 '你好，Python！'

# 尝试用 GBK 解码 UTF-8 字节串 (错误 -> 乱码或报错)
try:
    text3 = utf8_bytes.decode('gbk')
    print(text3)
except UnicodeDecodeError as e:
    print(f"解码错误: {e}") # 很可能会报错 UnicodeDecodeError: 'gbk' codec can't decode byte 0xef in position 6: illegal multibyte sequence
```

**<font color='green'>`decode()`：字节串 -> 字符串 (给人看的)</font>**

**<font color='orange'>处理文件读写、网络请求时，一定要注意编码问题！指定正确的 `encoding` 是关键！</font>**

## 字符串的遍历 - 逐个字符处理

想依次处理字符串里的每个字符？用 `for` 循环就行了，超级简单！

```python
message = "我爱Python"

for char in message:
    print(f"当前字符是：{char}")

# 输出:
# 当前字符是：我
# 当前字符是：爱
# 当前字符是：P
# 当前字符是：y
# 当前字符是：t
# 当前字符是：h
# 当前字符是：o
# 当前字符是：n
```

**<font color='purple'>`for` 循环遍历字符串，简单又高效！</font>**

## 字符串与列表的转换

字符串和列表经常需要互相转换。

### 字符串 -> 列表

*   用 `list(string)`：把字符串变成 **单个字符** 组成的列表。
*   用 `string.split(sep)`：按照 **分隔符** 把字符串切割成 **子串** 组成的列表 (前面讲过)。

```python
my_string = "Python"
char_list = list(my_string)
print(char_list) # 输出 ['P', 'y', 't', 'h', 'o', 'n']

sentence = "I love coding"
word_list = sentence.split(' ')
print(word_list) # 输出 ['I', 'love', 'coding']
```

### 列表 -> 字符串

*   用 `separator.join(list_of_strings)`：用 **分隔符** 把 **只包含字符串** 的列表连接成一个字符串 (前面也讲过)。

```python
word_list = ['Hello', 'world', '!']
separator = ' '
result_string = separator.join(word_list)
print(result_string) # 输出 'Hello world !'
```

**<font color='red'>`split()` 和 `join()` 是字符串列表互转的黄金搭档！</font>**

## 正则表达式初步 - 文本处理的利器（简单了解）

有时候，我们需要查找或匹配 **<font color='blue'>符合某种模式</font>** 的字符串，而不是固定的几个字。

比如：找出一段文字里所有的手机号、邮箱地址、或者以特定字母开头的单词。

这时候，普通字符串方法就有点不够用了，轮到 **正则表达式 (Regular Expression, Regex)** 登场了！

正则表达式就像一套 **描述文本模式的语言**，有点像给字符串画的“通缉令”。

Python 通过内置的 `re` 模块来支持正则表达式。

**<font color='orange'>注意：</font>** 正则表达式本身语法比较复杂，这里只做 **<font color='orange'>简单入门</font>**，让你知道有这么个强大的东西，以后有需要可以深入学习。

### 核心概念

*   **元字符 (Metacharacters)**：正则表达式里有特殊含义的字符，比如：
    *   `.` : 匹配除换行符外的 **任意单个字符**。
    *   `^` : 匹配字符串的 **开头**。
    *   `$` : 匹配字符串的 **结尾**。
    *   `*` : 匹配前面的子表达式 **零次或多次**。
    *   `+` : 匹配前面的子表达式 **一次或多次**。
    *   `?` : 匹配前面的子表达式 **零次或一次**。
    *   `{n}`: 匹配前面的子表达式 **恰好 n 次**。
    *   `{n,}`: 匹配前面的子表达式 **至少 n 次**。
    *   `{n,m}`: 匹配前面的子表达式 **至少 n 次，至多 m 次**。
    *   `[]`: 字符集，匹配方括号中的 **任意一个字符**。例如 `[abc]` 匹配 'a' 或 'b' 或 'c'。
    *   `()`: 分组，把多个字符当成一个单元，也可以用于捕获匹配的内容。
    *   `\`: 转义字符，用来匹配元字符本身 (例如 `\.`)，或者表示特殊序列 (例如 `\d` 匹配数字，`\s` 匹配空白，`\w` 匹配字母数字下划线)。

### `re` 模块常用函数

*   `re.match(pattern, string)`: 从字符串 **开头** 尝试匹配 `pattern`。如果开头不匹配，就算后面有匹配的也不行。匹配成功返回一个 Match 对象，否则返回 `None`。
*   `re.search(pattern, string)`: **扫描整个字符串**，查找 **第一个** 匹配 `pattern` 的位置。匹配成功返回 Match 对象，否则返回 `None`。
*   `re.findall(pattern, string)`: 查找字符串中 **所有** 匹配 `pattern` 的子串，并返回一个 **列表**。
*   `re.sub(pattern, repl, string)`: 把字符串中 **所有** 匹配 `pattern` 的子串替换成 `repl`，并返回 **新的字符串**。

### 简单示例

```python
import re

text = "My phone number is 138-1234-5678, and my email is test@example.com."

# 1. 查找手机号 (简化模式)
phone_pattern = r"\d{3}-\d{4}-\d{4}" # r"..." 表示原始字符串，避免转义麻烦
match_obj = re.search(phone_pattern, text)
if match_obj:
    print(f"找到了手机号：{match_obj.group(0)}") # group(0) 获取完整匹配
else:
    print("没找到手机号")

# 2. 查找所有单词
word_pattern = r"\b\w+\b" # \b 匹配单词边界，\w+ 匹配一个或多个字母数字下划线
all_words = re.findall(word_pattern, text)
print(f"所有单词：{all_words}")

# 3. 替换邮箱地址
email_pattern = r"\w+@\w+\.\w+"
new_text = re.sub(email_pattern, "[email protected]", text)
print(f"替换邮箱后：{new_text}")
```

**<font color='green'>正则表达式很强大，但学习曲线也比较陡峭。遇到复杂的文本匹配问题时，记得有它这个大杀器！</font>**

好啦，关于字符串的探险也告一段落了！

从简单的拼接、切片，到强大的格式化、各种方法，再到编码解码和正则表达式的初步接触，字符串的玩法是不是比你想象的要丰富多彩？

字符串处理是编程中非常非常常见的任务，把这些基础打扎实，以后写代码会顺手很多！

下一章，咱们要去探索 Python 里另一种重要的数据结构——字典和集合，敬请期待！