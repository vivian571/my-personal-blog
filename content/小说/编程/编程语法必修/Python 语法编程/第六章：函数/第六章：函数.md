---
title: "第六章：函数"
slug: "第六章：函数"
date: "2025-04-27T08:54:36.440549+00:00"
---

# 第六章：函数——Python 的代码"积木"游戏

嘿，小伙伴们！咱们已经学会了 Python 的基础知识、数据容器和条件循环，是不是感觉自己已经能写出一些有模有样的代码了？

但是，当你的程序越来越大，代码越来越多，你会发现：**<font color='red'>重复的代码太多了！</font>** 改一个地方可能要改十几处，简直要命！

这时候，**<font color='blue'>函数 (Function)</font>** 就闪亮登场了！函数就像是乐高积木，把一段代码"打包"起来，需要的时候随时拿来用，不需要重复写！

准备好了吗？今天咱们就来玩转 Python 函数，让你的代码更简洁、更强大、更优雅！

## 调用函数

其实你已经在用函数了！`print()`、`len()`、`type()` 这些都是 Python 内置的函数。

**<font color='green'>调用函数超简单：函数名 + 圆括号！</font>**

```python
# 调用内置函数
print("Hello, World!")  # 打印文本
length = len([1, 2, 3])  # 获取列表长度
print(length)  # 输出 3
```

**<font color='purple'>函数就是你的"小助手"，你一喊它名字，它就乖乖来帮忙！</font>**

## 定义函数

光用别人的函数哪够？咱们来学习自己造函数！

函数定义用 `def` 关键字，后面跟函数名和圆括号，别忘了冒号：

```python
# 定义一个简单的函数
def say_hello():
    print("你好，Python！")
    print("学习函数真有趣！")

# 调用这个函数
say_hello()  # 输出两行文本
```

**<font color='orange'>记住：</font>** 定义函数不会执行函数内的代码，只有调用函数时才会执行！

## 函数的参数

函数如果只能做固定的事情，那就太死板了。通过 **<font color='red'>参数 (Parameter)</font>**，函数可以接收外部数据，变得更灵活！

### 必须参数

最基本的参数形式，调用时必须提供：

```python
# 带必须参数的函数
def greet(name):
    print(f"你好，{name}！")

greet("小明")  # 输出：你好，小明！
# greet()  # 错误！缺少必须的参数
```

**<font color='blue'>必须参数就像点餐时的主食，必须选一个！</font>**

### 关键字参数

调用函数时，可以用 `参数名=值` 的形式指定参数，顺序就不重要了：

```python
# 多个参数的函数
def describe_person(name, age, city):
    print(f"{name}今年{age}岁，来自{city}。")

# 使用关键字参数
describe_person(city="上海", name="小红", age=25)  # 顺序不重要
```

**<font color='green'>关键字参数就像点外卖时备注：想说啥就说啥，顺序随意！</font>**

### 默认参数

有些参数可以设置默认值，调用时如果不提供，就用默认值：

```python
# 带默认参数的函数
def make_coffee(name, sugar="少量", milk=False):
    result = f"一杯{name}咖啡"
    if sugar:
        result += f"，加{sugar}糖"
    if milk:
        result += "，加奶"
    return result + "。"

print(make_coffee("美式"))  # 输出：一杯美式咖啡，加少量糖。
print(make_coffee("拿铁", "不加", True))  # 输出：一杯拿铁咖啡，加不加糖，加奶。
```

**<font color='purple'>默认参数就像餐厅的标配：不说就按常规上，要改就提前说！</font>**

### 可变参数

有时候，你不知道会传入多少个参数，可变参数来帮忙：

```python
# 可变位置参数 *args
def add_numbers(*numbers):
    total = 0
    for num in numbers:
        total += num
    return total

print(add_numbers(1, 2))  # 输出 3
print(add_numbers(1, 2, 3, 4, 5))  # 输出 15

# 可变关键字参数 **kwargs
def print_info(**info):
    for key, value in info.items():
        print(f"{key}: {value}")

print_info(name="小刚", age=30, job="程序员")
```

**<font color='red'>可变参数就像自助餐：想拿多少拿多少，随你便！</font>**

### 组合参数

各种参数可以组合使用，但要遵循顺序：必须参数 → 默认参数 → 可变位置参数 → 可变关键字参数

```python
# 组合使用各种参数
def complex_function(name, age=18, *hobbies, **other_info):
    print(f"姓名：{name}，年龄：{age}")
    if hobbies:
        print(f"爱好：{', '.join(hobbies)}")
    if other_info:
        print("其他信息：")
        for key, value in other_info.items():
            print(f"  {key}: {value}")

complex_function("小李", 22, "编程", "游泳", "阅读", city="北京", job="学生")
```

**<font color='orange'>参数组合，威力无穷！但记住顺序很重要！</font>**

## 执行流程

函数的执行流程很简单：
1. 调用函数时，程序跳转到函数体
2. 执行函数体内的代码
3. 函数执行完毕后，返回到调用处继续执行

```python
def step1():
    print("这是第一步")

def step2():
    print("这是第二步")

print("开始执行程序")
step1()
print("第一步和第二步之间")
step2()
print("程序执行结束")
```

**<font color='blue'>函数就像传送门，跳进去执行完再跳回来！</font>**

## 形参与实参

- **<font color='green'>形参 (Parameter)</font>**：定义函数时的"占位符"
- **<font color='green'>实参 (Argument)</font>**：调用函数时传入的实际值

```python
# name 和 age 是形参
def introduce(name, age):
    print(f"我叫{name}，今年{age}岁。")

# "张三" 和 25 是实参
introduce("张三", 25)
```

**<font color='purple'>形参像是函数的"插槽"，实参是塞进去的"数据卡"！</font>**

## 变量作用域

变量不是在哪都能用的，它有自己的"地盘"！

### 局部变量

在函数内部定义的变量是 **<font color='red'>局部变量</font>**，只能在函数内部使用：

```python
def local_test():
    x = 100  # 局部变量
    print(f"函数内部：x = {x}")

local_test()
# print(x)  # 错误！x 在函数外不可见
```

**<font color='blue'>局部变量就像酒店房间：住店时才能用，退房就没了！</font>**

### 全局变量

在函数外部定义的变量是 **<font color='red'>全局变量</font>**，可以在整个程序中使用：

```python
y = 200  # 全局变量

def global_test():
    print(f"函数内部：y = {y}")  # 可以读取全局变量

global_test()
print(f"函数外部：y = {y}")
```

**<font color='green'>全局变量就像公共场所：大家都能看到用到！</font>**

如果想在函数内修改全局变量，需要用 `global` 关键字：

```python
counter = 0  # 全局变量

def increase_counter():
    global counter  # 声明使用全局变量
    counter += 1
    print(f"计数器增加到：{counter}")

increase_counter()
increase_counter()
print(f"最终计数：{counter}")
```

**<font color='orange'>没有 global 声明，函数内部只能读不能改全局变量！</font>**

## 有返回值和无返回值函数

函数可以有 **<font color='red'>返回值</font>**，也可以没有。

### 无返回值函数

不使用 `return` 语句的函数，或者 `return` 后面没有值，都是无返回值函数：

```python
# 无返回值函数
def greet(name):
    print(f"你好，{name}！")
    # 没有 return 语句

result = greet("小明")  # 函数执行，打印问候语
print(f"函数返回值：{result}")  # 输出：函数返回值：None
```

**<font color='purple'>无返回值函数就像单向道：你给它东西，它干活，但不给你带回东西！</font>**

### 有返回值函数

使用 `return` 语句返回值的函数：

```python
# 有返回值函数
def calculate_area(length, width):
    area = length * width
    return area  # 返回计算结果

room_area = calculate_area(4, 5)  # 获取函数返回值
print(f"房间面积：{room_area}平方米")
```

**<font color='blue'>有返回值函数就像快递员：不仅收你的包裹，还给你送回东西！</font>**

`return` 语句一执行，函数就立即结束，后面的代码不会执行：

```python
def find_positive(numbers):
    for num in numbers:
        if num > 0:
            return num  # 找到正数就立即返回
    return None  # 如果没找到正数，返回 None

print(find_positive([-2, -1, 3, 5]))  # 输出：3
```

**<font color='green'>return 就像急刹车：一踩就停，后面的路不走了！</font>**

## 为什么要有函数

函数有啥好处？太多了！

1. **<font color='red'>代码复用</font>**：写一次，到处用，不用复制粘贴
2. **<font color='red'>代码组织</font>**：把相关功能放一起，代码更清晰
3. **<font color='red'>抽象封装</font>**：隐藏复杂细节，只关注功能接口
4. **<font color='red'>团队协作</font>**：不同人负责不同函数，并行开发

```python
# 没有函数的代码
print("计算第一个矩形面积")
length1 = 5
width1 = 3
area1 = length1 * width1
print(f"面积是：{area1}")

print("计算第二个矩形面积")
length2 = 7
width2 = 4
area2 = length2 * width2
print(f"面积是：{area2}")

# 使用函数的代码
def calculate_rectangle_area(length, width):
    area = length * width
    return area

print("计算第一个矩形面积")
area1 = calculate_rectangle_area(5, 3)
print(f"面积是：{area1}")

print("计算第二个矩形面积")
area2 = calculate_rectangle_area(7, 4)
print(f"面积是：{area2}")
```

**<font color='orange'>用了函数，代码更简洁，更易维护！</font>**

## 返回函数

函数不仅可以返回数据，还可以返回另一个函数！这就是 **<font color='red'>高阶函数</font>** 的魅力：

```python
# 返回函数的函数
def get_math_func(operation):
    # 加法函数
    def add(x, y):
        return x + y
    
    # 乘法函数
    def multiply(x, y):
        return x * y
    
    # 根据参数返回不同的函数
    if operation == "add":
        return add
    elif operation == "multiply":
        return multiply

# 获取加法函数
add_func = get_math_func("add")
print(add_func(5, 3))  # 输出：8

# 获取乘法函数
multiply_func = get_math_func("multiply")
print(multiply_func(5, 3))  # 输出：15
```

**<font color='purple'>返回函数就像变魔术：你要啥，我变出啥！</font>**

## 递归函数

### 递归函数的原理与概念

**<font color='red'>递归函数</font>** 是调用自身的函数。就像是套娃，一个函数里面又调用了自己。

递归的关键是：
1. 把大问题拆成小问题
2. 小问题和大问题的解法一样
3. 有一个最小问题（终止条件）

**<font color='blue'>递归就像照镜子里的镜子：一层套一层，但必须有个尽头！</font>**

### 经典递归案例：阶乘计算

阶乘是递归的经典例子：n! = n × (n-1)!

```python
# 递归计算阶乘
def factorial(n):
    # 基本情况（终止条件）
    if n == 0 or n == 1:
        return 1
    # 递归情况
    else:
        return n * factorial(n-1)

print(factorial(5))  # 输出：120 (5×4×3×2×1)
```

**<font color='green'>递归阶乘，层层调用，层层返回，最后算出结果！</font>**

### 递归的终止条件设置及重要性

递归必须有 **<font color='red'>终止条件</font>**，否则会无限递归，导致栈溢出错误：

```python
# 错误的递归（没有终止条件）
def infinite_recursion():
    print("这是一个无限递归")
    infinite_recursion()  # 无限调用自己，没有终止条件

# 不要运行上面的函数！会导致 RecursionError
```

**<font color='orange'>递归没有终止条件，就像无底洞，会让程序崩溃！</font>**

### 递归函数的性能分析与优化思路

递归虽然优雅，但可能效率不高：
1. 每次递归调用都要创建新的函数栈帧
2. 深度递归可能导致栈溢出
3. 重复计算问题（可用记忆化解决）

```python
# 普通递归斐波那契（效率低）
def fib_slow(n):
    if n <= 1:
        return n
    return fib_slow(n-1) + fib_slow(n-2)

# 优化：记忆化递归
def fib_fast(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    memo[n] = fib_fast(n-1, memo) + fib_fast(n-2, memo)
    return memo[n]

# 比较两种方法
import time

start = time.time()
print(fib_slow(30))
print(f"普通递归耗时：{time.time() - start}秒")

start = time.time()
print(fib_fast(30))
print(f"优化递归耗时：{time.time() - start}秒")
```

**<font color='purple'>递归优化很重要，否则可能慢如蜗牛！</font>**

## 匿名函数

### lambda 表达式语法与基本使用

**<font color='red'>匿名函数</font>** 是没有名字的小函数，用 `lambda` 关键字创建：

```python
# 普通函数
def square(x):
    return x * x

# 等价的匿名函数
square_lambda = lambda x: x * x

print(square(5))       # 输出：25
print(square_lambda(5))  # 输出：25
```

**<font color='blue'>lambda 就像函数界的"微型选手"：短小精悍，一行搞定！</font>**

### 匿名函数在 `map()`、`filter()` 等函数中的应用

匿名函数经常和 `map()`、`filter()` 等高阶函数一起使用：

```python
# map() 函数：对列表中每个元素应用函数
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x**2, numbers))
print(squared)  # 输出：[1, 4, 9, 16, 25]

# filter() 函数：筛选符合条件的元素
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(even_numbers)  # 输出：[2, 4]

# sorted() 函数：自定义排序
students = [("小明", 85), ("小红", 92), ("小刚", 78)]
# 按成绩排序
sorted_by_score = sorted(students, key=lambda student: student[1], reverse=True)
print(sorted_by_score)  # 按成绩从高到低排序
```

**<font color='green'>匿名函数配合高阶函数，一行代码顶十行！</font>**

### 匿名函数与普通函数的对比及适用场景

匿名函数 vs 普通函数：

| 特性 | 匿名函数 (lambda) | 普通函数 (def) |
| :--- | :--------------- | :------------- |
| **长度** | 只能写一行表达式 | 可以包含多行代码 |
| **复杂度** | 适合简单逻辑 | 适合复杂逻辑 |
| **命名** | 无名（可赋值给变量） | 有名字，便于重用 |
| **文档** | 不能有文档字符串 | 可以有文档字符串 |
| **适用场景** | 简单、一次性使用 | 复杂、多次使用 |

**<font color='orange'>匿名函数适合"一次性"的简单操作，复杂逻辑还是用普通函数！</font>**

---

好啦，小伙伴们！这一章我们学习了 Python 中的函数，这可是让代码更加模块化、可重用的强大工具！

有了函数，你可以把代码组织得更清晰，避免重复，提高开发效率。无论是内置函数、自定义函数，还是高级的递归函数、匿名函数，它们都是 Python 编程中不可或缺的"积木"。

下一章，我们将学习 Python 的面向对象编程，让你的代码更加结构化和专业化。敬请期待！

**<font color='red'>学习愉快，Python 加油！</font>**