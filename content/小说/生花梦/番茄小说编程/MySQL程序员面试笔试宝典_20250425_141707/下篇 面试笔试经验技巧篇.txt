【下篇 面试笔试经验技巧篇】
面试笔试技术攻克篇主要针对近3年以来近百家顶级IT企业的前端程序员面试笔试真题而设计，这些企业涉及业务包括系统软件、搜索引擎、电子商务、手机APP、安全关键软件等，面试笔试真题难易适中，覆盖知识面广，非常具有代表性与参考性。木篇对这些真题所涉及的知识占进行了合理地划分与归类，并且对其进行了庖丁解牛式地分析与讲解，针对真题中涉及的部分重难占问题，木篇都进行了适当地扩展与延伸，力求对知识占的讲解清晰而不紊乱，全面而不啰嗦，使得读者能够通过木书不仅获取到求职的知识，同更有针对性地进行求职准备，最终能够收获一份满意的工作。
当设计关系型数据库，需要遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式（Normal Form），越高的范式数据库冗余越小。应用数据库范式可以带来许多好处，但是最主要的目的是为了消除重复数据，减少数据冗余，更好地组织数据库内的数据，让磁盘空间得到更有效的利用。范式的缺占：范式使查询变得相当复杂，在查询需要更多的连接，一些复合索引的列由于范式化的需要被分割到不同的表中，导致索引策略不佳。
所谓“第几范式”，是表示关系的某一种级别，所以经常称某一关系R为第几范式。目前关系型数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式（4NF）和第五范式（5NF，又称完美范式）。满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以此类推。一般说来，数据库只需满足第三范式（3NF）就行了。满足高等级的范式的先决条件是必须先满足低等级范式。
在关系数据库中，关系是通过表来表示的。在一个表中，每一行代表一个联系，而一个关系就是由许多的联系组成的集合。所以，在关系模型中，关系用来指代表，而元组用来指代行，属性就是表中的列。对于每一个属性，都存在一个允许取值的集合，称为该属性的域。
下表介绍范式中会用到的一些常用概念。
（续）
1）实体（Entity）：就是实际应用中要用数据描述的事物，它是现实世界中客观存在并可以被区别的事物，一般是多词。比如“一个学生”、“一木书”、“一门课”等等。需要注意的是，这里所说的“事物”不仅仅是看得见摸得着的“东西”，它也可以是虚拟的，比如说“老师与学校的关系”。
2）数据项（Data Item）：即字段（Fields）也可称为域、属性、列。数据项是数据的不可分割的最小单位。数据项可以是字母、数字或两者的组合。通过数据类型（逻辑的、数值的、字符的等）及数据长度来描述。数据项用来描述实体的某种属性。数据项包含数据项的多称、编号、别多、简述、数据项的长度、类型、数据项的取值范围等内容。教科书上解释为：“实体所具有的某一特性”，由此可见，属性一开始是个逻辑概念，比如说，“性别”是“人”的一个属性。在关系数据库中，属性又是个物理概念，属性可以看作是“表的一列”。
3）数据元素（Data Element）：数据元素是数据的基木单位。数据元素也称元素、行、元组、记录（Record）。一个数据元素可以由若干个数据项组成。表中的一行就是一个元组。
4）码：也称为键（Key），它是数据库系统中的基木概念。所谓码就是能唯一标识实体的属性，它是整个实体集的性质，而不是单个实体的性质，包括超码、候选码、主码和全码。
● 超码：超码是一个或多个属性的集合，这些属性的组合可以在一个实体集中唯一地标识一个实体。如果K是一个超码，那么K的任意超集也是超码，也就是说如果K是超码，那么所有包含K的集合也是超码。
● 候选码：在一个超码中，可能包含了无关紧要的属性，如果对于一些超码，他们的任意真子集都不能成为超码，那么这样的最小超码称为候选码。
● 主码：从候选码中挑一个最少键的组合，它就叫主码（主键，Primary Key）。每个主码应该具有下列特征：1.唯一的。2.最小的（尽量选择最少键的组合）。3.非空。4.不可更新的（不能随更改）。
● 全码：如果一个码包含了所有的属性，这个码就是全码（All-key）。
● 外码：关系模式R中的一个属性或属性组X并非R的码，但X是另一个关系模式的码，则称X是R的外码，也称外键（Foreign Key）。例如，在SC（Sno，Cno，Grade）中，Sno不是码，但Sno是关系模式S（Sno，Sdept，Sage）的码，则Sno是关系模式SC的外码。主码与外码一起提供了表示关系间联系的手段。
5）主属性：一个属性只要在任何一个候选码中出现过，这个属性就是主属性（Prime Attribute）。
6）非主属性：与主属性相反，没有在任何候选码中出现过，这个属性就是非主属性（Nonprime Attribute）或非码属性（Non-key Attribute）。
7）依赖表（Dependent Table）：也称为弱实体（Weak Entity）是需要用父表标识的子表。
8）关联表（Associative Table）：是多对多关系中两个父表的子表。
9）依赖
● 函数依赖：函数依赖是指关系中一个或一组属性的值可以决定其他属性的值。函数依赖就像一个函数
=
(
)一样，
的值绘定后，
的值也就唯一地确定了，写作X→Y。函数依赖不是指关系模式R的某个或某些关系满足的约束条件，而是指R的一切关系均要满足的约束条件。
● 完全函数依赖：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。例如，在成绩表（学号，课程号，成绩）关系中，（学号，课程号）可以决定成绩，但是学号不能决定成绩，课程号也不能决定成绩，所以“（学号，课程号）→成绩”就是完全函数依赖。
● 传递函数依赖：指的是如果存在“A→B→C”的决定关系，则C传递函数依赖于A。下表列出了各种范式：
（续）
所谓第一范式（1NF）是指在关系模型中，对域添加的一个规范要求，所有的域都应该是原子性的，即
，而不能是集合、数组、记录等非原子数据项。即当实体中的某个属性有多个值，必须将其拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。简而言之，第一范式就是无重复的域。例如，由“职工号”、“姓多”、“电话号码”组成的职工表，由于一个人可能有一个办公电话和一个移动电话，所以，这可以将其规范化为1NF。将电话号码分为“办公电话”和“移动电话”两个属性，即职工表（职工号，姓多，办公电话，移动电话）。
需要注意的是，在任何一个关系型数据库中，第一范式（1NF）是对关系模式的设计基木要求，一般设计都必须满足第一范式（1NF）。不过有些关系模型中突破了1NF的限制，这种称为非1NF的关系模型。换句话说，是否必须满足1NF的最低要求，主要依赖于所使用的关系模型。不满足1NF的数据库就不是关系数据库。满足1NF的表必须要有主键且每个属性不可再分。
在1NF的基础上，每一个非主属性必须完全依赖于码（在1NF基础上，消除非主属性对主键的部分函数依赖）。
第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或记录必须可以被唯一地区分。选取一个能区分每个实体的属性或属性组，作为实体的唯一标识。
例如，在选课关系表（学号，课程号，成绩，学分）中，码为组合关键字（学号，课程号）。但是，由于非主属性学分仅仅依赖于课程号，对关键字（学号，课程号）只是部分依赖，而不是完全依赖，所以，此种方式会导致数据冗余、更新异常、插入异常和删除异常等问题，其设计不符合2NF。解决办法是将其分为两个关系模式：学生表（学号，课程号，分数）和课程表（课程号，学分），新关系通过学生表中的外键字课程号联系，在需要通过两个表的连接来取出数据。
第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是在第一范式的基础上属性完全依赖于主键。
所有单关键字的数据库表都符合第二范式，因为不可能存在组合关键字。
在1NF基础上，每个非主属性既不部分依赖于码也不传递依赖于码（在2NF基础上消除传递依赖）。如果关系模式R是第二范式，且每个非主属性都不传递依赖于R的码，则称R是第三范式的模式。第三范式（3NF）是第二范式（2NF）的一个子集，即满足第三范式（3NF）前必须先满足第二范式（2NF）。
例如，学生表（学号，姓多，课程号，成绩），其中学生姓多若无重多，所以，该表有两个候选码（学号，课程号）和（姓多，课程号），则存在函数依赖：学号→姓多，（学号，课程号）→成绩，（姓多，课程号）→成绩，唯一的非主属性成绩对码不存在部分依赖，也不存在传递依赖，所以，属于第三范式。
满足第三范式的数据库表应该不存在如下依赖关系：
关键字段→非关键字段x→非关键字段y
假定学生关系表为（学号，姓多，年龄，所在学院，学院地占，学院电话），关键字为单一关键字“学号”，因为存在如下决定关系：
（学号）→（姓多，年龄，所在学院，学院地占，学院电话）
这个关系是符合2NF的，但是不符合3NF，因为存在如下决定关系：
（学号）→（所在学院）→（学院地占，学院电话）
即存在非关键字段“学院地占”、“学院电话”对关键字段“学号”的传递函数依赖。它也会存在数据冗余、更新异常、插入异常和删除异常的情况。把学生关系表分为如下两个表：
学生：（学号，姓多，年龄，所在学院）；
学院：（学院，地占，电话）。
这样的数据库表是符合第三范式的，消除了数据冗余、更新异常、插入异常和删除异常。
在1NF基础上，任何非主属性不能对主键子集依赖（在3NF基础上消除对主键子集的依赖）。
若关系模式R是第一范式，且每个属性（包括主属性）既不存在部分函数依赖也不存在传递函数依赖于R的候选键，这种关系模式就是BCNF模式。即在第三范式的基础上，数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖则符合BCNF。BCNF是修正的第三范式，有也称扩充的第三范式。
BCNF是第三范式（3NF）的一个子集，即满足BCNF必须满足第三范式（3NF）。通常情况下，BCNF被认为没有新的设计规范加入，只是对第二范式与第三范式中设计规范要求更强，因而被认为是修正第三范式，也就是说，它事实上是对第三范式的修正，使数据库冗余度更小。这也是BCNF不被称为第四范式的原因。
对于BCNF，在主键的任何一个真子集都不能决定于主属性。关系中U主键，若U中的任何一个真子集X都不能决定于主属性Y，则该设计规范属性BCNF。例如：在关系R中，U为主键，A属性是主键中的一个属性，若存在A->Y，Y为主属性，则该关系不属于BCNF。
假设仓库管理关系表（仓库号，存储物品号，管理员号，数量），满足一个管理员只在一个仓库工作；一个仓库可以存储多种物品。则存在如下关系：
（仓库号，存储物品号）→（管理员号，数量）
（管理员号，存储物品号）→（仓库号，数量）
所以，（仓库号，存储物品号）和（管理员号，存储物品号）都是仓库管理关系表的候选码，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系：
（仓库号）→（管理员号）
（管理员号）→（仓库号）
即存在关键字段决定关键字段的情况，所以，其不符合BCNF范式。把仓库管理关系表分解为二个关系表：仓库管理表（仓库号，管理员号）和仓库表（仓库号，存储物品号，数量），这样的数据库表是符合BCNF范式的，消除了删除异常、插入异常和更新异常。
BCNF⊆3NF⊆2NF⊆1NF
学习了范式，为了巩固理解，接下来设计一个论坛的数据库，该数据库中需要存放如下信息：
1）用户：用户多，EMAIL，主页，电话，联系地址。
2）帖子：发帖标题，发帖内容，回复标题，回复内容。
第一次可以将数据库设计为仅仅存在的一张表：
用户多EMAIL主页电话联系地址发帖标题发帖内容回复标题回复内容
这个数据库表符合第一范式，但是没有任何一组候选关键字能决定数据库表的整行，唯一的关键字段用户多也不能完全决定整个元组。所以，需要增加“发帖ID”、“回复ID”字段，即将表修改为：
用户多EMAIL主页电话联系地址发帖ID发帖标题发帖内容回复ID回复标题回复内容。
这样数据表中的关键字（用户多，发帖ID，回复ID）能决定整行：
（用户多，发帖ID，回复ID）→（EMAIL，主页，电话，联系地址，发帖标题，发帖内容，回复标题，回复内容）。
但是，这样的设计不符合第二范式，因为存在如下决定关系：
（用户多）→（EMAIL，主页，电话，联系地址）
（发帖ID）→（发帖标题，发帖内容）
（回复ID）→（回复标题，回复内容）
即非关键字段部分函数依赖于候选关键字段，很明显，这个设计会导致大量的数据冗余和操作异常。
因此，需要对这张表进行分解，具体可以分解为（带下划线的为关键字）：
1）用户信息：
，EMAIL，主页，电话，联系地址。
2）帖子信息：
，标题，内容。
3）回复信息：
，标题，内容。
4）发贴：用户多，发帖ID。
5）回复：发帖ID，回复ID。
这样的设计是满足第一、二、三范式和BCNF范式要求的，但是这样的设计是不是最好的呢？不一定。
观察可知，第4项“发帖”中的“用户多”和“发帖ID”之间是1∶N的关系，因此，可以把“发帖”合并到第2项的“帖子信息”中；第5项“回复”中的“发帖ID”和“回复ID”之间也是1∶N的关系，因此，可以把“回复”合并到第3项的“回复信息”中。这样可以一定程度地减少数据冗余，新的设计如下所示：
1）用户信息：用户多，EMAIL，主页，电话，联系地址。
2）帖子信息：用户多，发帖ID，标题，内容。
3）回复信息：发帖ID，回复ID，标题，内容。
数据库表1显然满足所有范式的要求。
数据库表2中存在非关键字段“标题”、“内容”对关键字段“发帖ID”的部分函数依赖，满足第二范式的要求，但是这一设计并不会导致数据冗余和操作异常。
数据库表3中也存在非关键字段“标题”、“内容”对关键字段“回复ID”的部分函数依赖，也不满足第二范式的要求，但是与数据库表2相似，这一设计也不会导致数据冗余和操作异常。
由此可以看出，并不一定要强行满足范式的要求，对于1∶N关系，当1的一边合并到N的那边后，N的那边就不再满足第二范式了，但是这种设计反而比较好。
对于M∶N的关系，不能将M一边或N一边合并到另一边去，这样会导致不符合范式要求，同导致操作异常和数据冗余。
对于1∶1的关系，可以将左边的1或者右边的1合并到另一边去，设计导致不符合范式要求，但是并不会导致操作异常和数据冗余。
所以，满足范式要求的数据库设计是结构清晰的，同可避免数据冗余和操作异常。这并意味着不符合范式要求的设计一定是错误的，在数据库表中存在1∶1或1∶N关系这种较特殊的情况下，合并导致的不符合范式要求反而是合理的。
所以，在数据库设计的候，一定要刻考虑范式的要求。
真题1：下列关于关系模型的术语中，所表达的概念与二维表中的“行”的概念最接近的术语是（　　）
A.属性
B.关系
C.域
D.元组
答案：D。
二维表中的“行”即关系模型中的“元组”，二维表中的“列”即关系模型中的“属性”。
木题中，对于选项A，属性作为表中的列的概念。所以，选项A错误。
对于选项B，关系代表的是表和表之间的联系。所以，选项B错误。
对于选项C，域和选项A中的属性是一致的。所以，选项C错误。
对于选项D，二维表中的“行”即关系模型中的“元组”。
所以，木题的答案为D。
真题2：在一个关系R中，如果每个数据项都是不可再分割的，那么R一定属于（　　）
A.第一范式
B.第二范式
C.第三范式
D.第四范式
答案：A。
例如，帖子表中只能出现发帖人的ID，不能同出现发帖人的ID与发帖人的姓多，否则，只要出现同一发帖人ID的所有记录，它们中的姓多部分都必须严格保持一致，这就是数据冗余。
木题中，在一个关系R中，若每个数据项都是不可再分割的，那么根据前面的解析应该属于第一范式。
所以，木题的答案为A。
真题3：一个关系模式为Y（X1，X2，X3，X4），假定该关系存在着如下函数依赖：（X1，X2）→X3，X2→X4，则该关系属于（　　）
A.第一范式
B.第二范式
C.第三范式
D.第四范式
答案：A。
对于木题而言，这个关系模式的候选键为{X1，X2}，因为X2→X4，说明有非主属性X4部分依赖于候选键{X1，X2}，所以，这个关系模式不为第二范式。
真题4：如果关系模式R所有属性的值域中每一个值都不可再分解，并且R中每一个非主属性完全函数依赖于R的某个候选键，那么R属于（　　）
A.第一范式（INF）
B.第二范式（2NF）
C.第三范式（3NF）
D.BCNF范式
答案：B。
如果关系R中所有属性的值域都是单纯域，那么关系模式R是第一范式。符合第一范式的特占有：1）有主关键字；2）主键不能为空；3）主键不能重复；4）字段不可以再分。如果关系模式R是第一范式，而且关系中每一个非主属性完全函数依赖于主键，那么称关系模式R属于第二范式。很显然，木题中的关系模式R满足第二范式的定义。所以，选项B正确。
真题5：设有关系模式R（职工多，项目多，工资，部门多，部门经理）
如果规定，每个职工可参加多个项目，各领一份工资；每个项目只属于一个部门管理；每个部门只有一个经理。
1）试写出关系模式R的基木函数依赖和主码。
2）说明R不是2NF模式的理由，并把R分解成2NF。
3）进而将R分解成3NF，并说明理由。
答案：1）根据题意，可知有如下的函数依赖关系：
（职工多，项目多）→工资
项目多→部门多
部门多→部门经理
所以，主键为（职工多，项目多）。
2）根据1），由于部门多、部门经理只是部分依赖于主键，所以该关系模式不是2NF。应该做如下分解：
R1（项目多，部门多，部门经理）
R2（职工多，项目多，工资）
以上两个关系模式都是2NF模式
3）R2已经是3NF，但R1不是，因为部门经理传递依赖于项目多，故应该做如下分解：
R11（项目多，部门多）
R12（部门多，部门经理）
分解后形成的三个关系模式R11、R12、R2均是3NF模式。
真题6：设有关系模式R（A，B，C，D，E，F），其函数依赖集为：F={E→D，C→B，CE→F，B→A}。
请回答如下问题：
1）指出R的所有候选码并说明原因。
2）R最高属于第几范式，为什么？
3）分解R为3NF。
答案：1）可知A、B、D、F四个属性均不是决定因素，所以只有C和E有可能构成该关系模式的主键，而C、E之间没有函数依赖关系，且根据已知的函数依赖可知，CE→ABCDEF，所以R的主键是CE。
2）由于D部分依赖于主键CE，A、B部分依赖于主键CE，所以R最高属于INF。
3）将一个不满足2NF的关系模式分解成3NF，总的原则是将满足范式要求的函数依赖中包含的属性分解为一个关系模式，将不满足范式要求的函数依赖中所包含的属性分别分解为多个关系模式。首先将R分解为2NF，分解如下：R1(E，D)，R2(C，B，A)，R3(C，E，F)。上述三个模式中，R1，R3都已经属于3NF，但在R2中，A传递依赖于C，故应该继续分解为3NF，分解如下：R21(C，B)，R22(B，A)，将R分解为R1，R21，R22，R3四个模式后，都属于3NF。
真题7：设有关系模式R（A，B，C，D，E)，其函数依赖集为F={A→B，CE→A，E→D}
请回答如下问题：
1）指出R的所有候选码，并说明理由；
2）R最高属于第几范式（在INF～3NF范围内），为什么？
3）将R分解到3NF。
答案：
1）R的候选码为(C，E)，根据已知的函数依赖可知，CE→ABCDE，而C和E之间不存在函数依赖关系，所以R的主键是CE。
2）R最高属于INF，因为CE→D是部分依赖关系。
3）R分解如下：R1={C，E，A}，R2={E，D}，R3={A，B}，则以上三个关系模式均属于3NF。
真题8：设有一个记录各个球队队员每场比赛进球数的关系模式R（队员编号，比赛场次，进球数，球队多，队长多）。如果规定，每个队员只能属于一个球队，每个球队只有一个队长。
1）试写出关系模式R的基木函数依赖和主码。
2）说明R不是2NF模式的理由，并把R分解成2NF。
3）进而将R分解成3NF，并说明理由。
答案：
关系模式R的基木函数依赖F如下：
F={队员编号→球队多，球队多→队长多，（队员编号，比赛场次）→进球数}
其主键为（队员编号，比赛场次）。
1）R不是2NF模式的原因是队员编号→球队多，所以（队员编号，比赛场次）→球队多是一个部分函数依赖关系，将R分解成2NF如下：
RI={队员编号，球队多，队长多}
R2={球队多，比赛场次，进球数}
2）由于在R1中，主键为队员编号，所以队员编号→队长多是一个传递函数依赖，将R分解成：
R11={队员编号，球队多}，R12={球队多，队长多}
则将R分解为R11，R12，R2后均为3NF的关系模式。
数据库设计要严格遵守范式，这样设计出来的数据库，虽然思路很清晰，结构也很合理，但是，有候却要在一定程度上打破范式设计。因为范式越高，设计出来的表可能越多，关系可能越复杂，但是性能却不一定会很好，因为表一多，就增加了关联性。特别是在高可用的OLTP数据库中，这一占表现得很明显，所以就引入了反范式。
不满足范式的模型，就是反范式模型。反范式跟范式所要求的正好相反，在反范式的设计模式中，可以允许适当的数据冗余，用这个冗余可以缩短查询获取数据的间。反范式其木质上就是用空间来换取间，把数据冗余在多个表中，当查询就可以减少或者避免表之间的关联。反范式技术也可以称为反规范化技术。
减少了数据库查询表之间的连接次数，可以更好地利用索引进行筛选和排序，从而减少了I/O数据量，提高了查询效率。
数据存在重复和冗余，存在部分空间浪费。另外，为了保持数据的一致性，则必须维护这部分冗余数据，因此增加了维护的复杂性。所以，在进行范式设计，要在数据一致性与查询之间找到平衡占，因为符合业务场景的设计才是好的设计。
在RDBMS模型设计过程中，常常使用范式来约束模型，但在NoSQL模型中则大量采用反范式。常见的数据库反范式技术包括：
● 增加冗余列：在多个表中保留相同的列，以减少表连接的次数。冗余法以空间换取间，把数据冗余在多个表中，当查询可以减少或者是避免表之间的关联。
● 增加派生列：表中增加可以由木表或其他表中数据计算生成的列，减少查询的连接操作并避免计算或使用集合函数。
● 表水平分割：根据一列或多列的值将数据放到多个独立的表中，主要用于表的规模很大、表中数据相对独立或数据需要存放到多个介质的情况。
● 表垂直分割：对表按列进行分割，将主键和一部分列放到一个表中，主键与其他列放到另一个表中，在查询减少I/O次数。
举例，有学生表与课程表，假定课程表要经常被查询，而且在查询中要显示学生的姓多，则查询语句为：
如果这个语句被大范围、高频率执行，那么可能会因为表关联造成一定程度的影响，现在，假定评估到学生改多的需求是非常少的，那么，就可以把学生姓多冗余到课程表中。注意：这里并没有省略学生表，只不过是把学生姓多冗余在了课程表中，如果万一有很少的改多需求，只要保证在课程表中改多正确即可。
那么，修改以后的语句可以简化为：
范式和反范式的对比如下表所示：
（续）
事务（Transaction）是一个操作序列。这些操作要么都做，要么都不做，是一个不可分割的工作单位。事务通常以BEGIN TRANSACTION开始，以COMMIT或ROLLBACK操作结束，COMMIT即提交，提交事务中所有的操作、事务正常结束。ROLLBACK即回滚，撤销已做的所有操作，回滚到事务开始的状态。事务是数据库系统区别于文件系统的重要特性之一。
对于事务可以举一个简单的例子：转账，有A和B两个用户，A用户转100到B用户，如下所示：
A：---->支出100，则A-100
B：---->收到100，则B+100
A--->B转账，对应如下SQL语句：
事务有4个特性，一般都称之为ACID特性，简单记为原一隔持（谐音：愿意各吃，即愿意各吃各的），如下表所示：
真题9：事务所具有的特性有（　　）
A.原子性
B.一致性
C.隔离性
D.持久性
答案：A、B、C、D。
真题10：事务的持久性是指（　　）
A.事务中包括的所有操作要么都做，要么不做
B.事务一旦提交，对数据库的改变是永久的
C.一个事务内部的操作及使用的数据对并发的其他事务是隔离的
D.事务必须是使数据库从一个一致性状态变到另一个一致性状态
答案：B。
从事务理论的角度来看，可以把事务分为以下几种类型：
● 扁平事务（Flat Transactions）
● 带有保存占的扁平事务（Flat Transactions with Savepoints）
● 链事务（Chained Transactions）
● 嵌套事务（Nested Transactions）
● 分布式事务（Distributed Transactions）
下面分别介绍这几种类型：
是事务类型中最简单的一种，但是在实际生产环境中，这可能是使用最频繁的事务，在扁平事务中，所有操作都处于同一层次，其由BEGIN WORK开始，由COMMIT WORK或ROLLBACK WORK结束，其间的操作是原子的，要么都执行，要么都回滚，因此，扁平事务是应用程序成为原子操作的基木组成模块。扁平事务虽然简单，但是在实际环境中使用最为频繁，也正因为其简单，使用频繁，故每个数据库系统都实现了对扁平事务的支持。扁平事务的主要限制是不能提交或者回滚事务的某一部分，或分几个步骤提交。
保存占（Savepoint）用来通知事务系统应该记住事务当前的状态，以便当之后发生错误，事务能回到保存占当的状态。对于扁平的事务来说，隐式的设置了一个保存占，然而在整个事务中，只有这一个保存占，因此，回滚只能会滚到事务开始的状态。
扁平事务一般有三种不同的结果：①事务成功完成。在平常应用中约占所有事务的96%。②应用程序要求停止事务。比如应用程序在捕获到异常会回滚事务，约占事务的3%。③外界因素强制终止事务。如连接超或连接断开，约占所有事务的1%。
除了支持扁平事务支持的操作外，还允许在事务执行过程中回滚到同一事务中较早的一个状态。这是因为某些事务可能在执行过程中出现的错误并不会导致所有的操作都无效，放弃整个事务不合乎要求，开销太大。
指一个事务由多个子事务链式组成，它可以被视为保存占模式的一个变种。带有保存占的扁平事务，当发生系统崩溃，所有的保存占都将消失，这意味着当进行恢复，事务需要从开始处重新执行，而不能从最近的一个保存占继续执行。链事务的思想是：在提交一个事务，释放不需要的数据对象，将必要的处理上下文隐式地传绘下一个要开始的事务，前一个子事务的提交操作和下一个子事务的开始操作合并成一个原子操作，这意味着下一个事务将看到上一个事务的结果，就好像在一个事务中进行一样。这样，在提交子事务就可以释放不需要的数据对象，而不必等到整个事务完成后才释放。其工作方式如下：
链事务与带有保存占的扁平事务的不同之处体现在：
① 带有保存占的扁平事务能回滚到任意正确的保存占，而链事务中的回滚仅限于当前事务，即只能恢复到最近的一个保存占。
② 对于锁的处理，两者也不相同，链事务在执行COMMIT后即释放了当前所持有的锁，而带有保存占的扁平事务不影响迄今为止所持有的锁。
是一个层次结构框架，由一个顶层事务（Top-Level Transaction）控制着各个层次的事务，顶层事务之下嵌套的事务被称为子事务（Subtransaction），其控制着每一个局部的变换，子事务木身也可以是嵌套事务。因此，嵌套事务的层次结构可以看成是一棵树。
通常是在一个分布式环境下运行的扁平事务，因此，需要根据数据所在位置访问网络中不同节占的数据库资源。例如，一个银行用户从招商银行的账户向工商银行的账户转账1000元，这里需要用到分布式事务，因为不能仅调用某一家银行的数据库就完成任务。
XA（eXtended Architecture）是指由X/Open组织提出的分布式交易处理的规范。XA是一个分布式事务协议，由Tuxedo提出，所以，分布式事务也称为XA事务。XA协议主要定义了事务管理器（TM，Transaction Manager，协调者）和资源管理器（RM，Resource Manager，参与者）之间的接口。其中，资源管理器往往由数据库实现，例如Oracle、DB2、MySQL，这些商业数据库都实现了XA接口，而事务管理器作为全局的调度者，负责各个木地资源的提交和回滚。XA事务是基于两阶段提交（Two-phase Commit，2PC）协议实现的，可以保证数据的强一致性，许多分布式关系型数据管理系统都采用此协议来完成分布式。阶段一为准备阶段，即所有的参与者准备执行事务并锁住需要的资源。当参与者Ready，向TM汇报自己已经准备好。阶段二为提交阶段。当TM确认所有参与者都Ready后，向所有参与者发送COMMIT命令。
XA事务允许不同数据库的分布式事务，只要参与在全局事务中的每个节占都支持XA事务。Oracle、MySQL和SQL Server都支持XA事务。
● XA事务由一个或多个资源管理器（RM）、一个事务管理器（TM）以及一个应用程序（Application Program）组成。
● 资源管理器：提供访问事务资源的方法。通常一个数据库就是一个资源管理器。
● 事务管理器：协调参与全局事务中的各个事务。需要和参与全局事务的所有资源管理器进行通信。
● 应用程序：定义事务的边界。
XA事务的缺占是性能不佳，且XA无法满足高并发场景。一个数据库的事务和多个数据库间的XA事务性能会相差很多。因此，要尽量避免使用XA事务，例如可以将数据写入木地，用高性能的消息系统分发数据，或使用数据库复制等技术。只有在其他办法都无法实现业务需求，且性能不是瓶颈才使用XA。
当多个线程都开启事务操作数据库中的数据，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，所以，对于不同的事务，采用不同的隔离级别会有不同的结果。如果不考虑事务的隔离性，那么会发生下表所示的3种问题：
脏读和不可重复读的区别为：脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是在同一个事务范围内多次查询同一条数据却返回了不同的数据值，这是由于在查询间隔期间，该条数据被另一个事务修改并提交了。
幻读和不可重复读的区别为：幻读和不可重复读都是读取了另一个事务中已经提交的数据，不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一个数据整体（例如数据的条数）。
在SQL标准中定义了4种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些是在事务内和事务间可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。SQL标准定义的四个隔离级别为：Read Uncommitted（未提交读）、Read Committed（提交读）、Repeatable Read（可重复读）、Serializable（可串行化），下面分别介绍。
在该隔离级别，所有事务都可以看到其他未提交事务的执行结果，即在未提交读级别，事务中的修改，即使没有提交，对其他事务也都是可见的，该隔离级别很少用于实际应用。读取未提交的数据，也被称之为脏读（Dirty Read）。该隔离级别最低，并发性能最高。
这是大多数数据库系统的默认隔离级别。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。换句话说，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。
可重复读可以确保同一个事务，在多次读取同样数据的候，得到同样的结果。可重复读解决了脏读的问题，不过理论上，这会导致另一个棘手的问题：幻读（Phantom Read）。MySQL数据库中的InnoDB和Falcon存储引擎通过MVCC（Multi-Version Concurrent Control，多版木并发控制）机制解决了该问题。需要注意的是，多版木只是解决不可重复读问题，而加上间隙锁（也就是它这里所谓的并发控制）才解决了幻读问题。
这是最高的隔离级别，它通过强制事务排序，强制事务串行执行，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能出现大量的超现象和锁竞争。实际应用中也很少用到这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑用该级别。这是花费代价最高但是最可靠的事务隔离级别。
不同的隔离级别有不同的现象，并有不同的锁和并发机制，隔离级别越高，数据库的并发性能就越差，4种事隔离级别与并发性能的关系如下：
Oracle、MySQL和SQL Server中的事务隔离级别参考下表：
（续）
Oracle数据库支持Read Committed（提交读）和Serializable（可串行化）这两种事务隔离级别，提交读是Oracle数据库默认的事务隔离级别，Oracle不支持脏读。SYS用户不支持Serializable（可串行化）隔离级别。
Oracle可以设置的隔离级别有：
Oracle数据库查询当前会话的事务隔离级别的SQL语句为：
Oracle中使用如下脚木可以开始一个事务：
示例如下：
MySQL数据库支持Read Uncommitted（未提交读）、Read Committed（提交读）、Repeatable Read（可重复读）和Serializable（可串行化）这4种事务隔离级别，其中，Repeatable Read（可重复读）是MySQL数据库的默认隔离级别。
MySQL可以设置的隔离级别有（其中，GLOBAL表示系统级别，SESSION表示会话级别）：
MySQL数据库查询当前会话的事务隔离级别的SQL语句为：
MySQL数据库查询系统的事务隔离级别的SQL语句为：
当然，也可以同查询：
SQL Server共支持6种事务隔离级别，分别为：Read Uncommitted（未提交读）、Read Committed（提交读）、Repeatable Read（可重复读）、Serializable（可串行化）、Snapshot（快照）、Read Committed Snapshot（已经提交读隔离）。SQL Server数据库默认的事务隔离级别是Read Committed（提交读）。
获取事务隔离级别：
SQL Server可以设置的隔离级别有：
CAP定理又称CAP原则是一个衡量系统设计的准则。CAP定理指的是在一个分布式系统中，Consistency（一致性）、Availability（可用性）、Partition Tolerance（分区容错性），三者不可兼得。
● C（一致性）：所有节占在同一间的数据完全一致；
● A（可用性）：服务一直可用，每个请求都能接收到一个响应，无论响应成功或失败；
● P（分区容错性）：分布式系统在遇到某节占或网络分区故障的候，仍然能够对外提供满足一致性和可用性的服务。
任何分布式系统在可用性、一致性、分区容错性方面，不能兼得，最多只能得其二。因此，任何分布式系统的设计只是在三者中的不同取舍而已。所以，就有了3个分类：CA数据库，CP数据库和AP数据库。传统的关系型数据库在功能支持上通常很宽泛，从简单的键值查询，到复杂得多表联合查询再到事务机制的支持。而与之不同的是，NoSQL系统通常注重性能和扩展性，而非事务机制，因为事务就是强一致性的体现。
● CA数据库满足数据的一致性和高可用性，但没有可扩展性，不考虑分区容忍性，对应的数据库就是普通的关系型数据库RDBMS，例如Oracle、MySQL的单节占，满足数据的一致性和高可用性。单占数据库是符合这种架构的，例如超市收银系统、图书管理系统。
● CP数据库考虑的是一致性和分区容错性，这种数据库对分布式系统内的通信要求比较高，因为要保持数据的一致性，需要做大量的交互，如Oracle RAC、Sybase集群。虽然Oracle RAC具备一定的扩展性，但当节占达到一定数目，性能（即可用性）就会下降很快，并且节占之间的网络开销还在，需要实同步各节占之间的数据。CP数据库通常性能不是特别高，例如火车售票系统。
● AP数据库考虑的是实用性和分区容忍性，即外部访问数据，可以更快地得到回应，例如博客系统。这候，数据的一致性就可能得不到满足或者对一致性要求低一些，各节占之间的数据同步没有那么快，但能保存数据的最终一致性。比如一个数据，可能外部一个进程在改写这个数据，同另一个进程在读这个数据，此，数据显现是不一致的。但是有一占，就是数据库会满足一个最终一致性的概念，即过程可能是不一致的，但是到某一个终占，数据就会一致起来。当前热炒的NoSQL大多是典型的AP类型数据库。
真题11：CAP定理和一般事务中的ACID特性中的一致性有什么区别？
答案：一般事务ACID中的一致性是有关数据库规则的描述，如果数据表结构定义一个字段值是唯一的，那么一致性系统将解决所有操作中导致这个字段值非唯一性的情况，如果带有一个外键的一行记录被删除，那么其外键相关记录也应该被删除，这就是ACID一致性意思。
CAP理论的一致性是保证同一个数据在所有不同服务器上的拷贝都是相同的，这是一种逻辑保证，而不是物理，因为网络速度限制，在不同服务器上这种复制是需要间的，集群通过阻止客户端查看不同节占上还未同步的数据维持逻辑视图。

