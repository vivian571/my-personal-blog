【第3章 文件与数据存储】
Python以简洁见长，在其他语言中比较复杂的文件读写和数据IO，在Python中由于比较简单的语法和丰富的类库而显得尤为方便。这一章将从最简单的文木文件读写出发，重占介绍CSV文件读写和操作数据库，同介绍一些其他形式的数据存储方式。
谈到Python中的文件读写，总会使人想到“open”关键字，其最基木的操作如下面的示例：
不难发现，在open()的参数中，第一个是文件路径，第二个则是模式字符（串）。模式字符（串）代表了不同的文件打开方式，比较常用的是“r”（代表读），“w”（代表写），“a”（代表写，并追加内容）。“w”和“a”常常被混淆，其区别在于：如果用“w”模式打开一个已存在的文件，会清空文件中的内容，重新写入新的内容；如果用“a”，则不会清空原有数据，而是继续追加写入内容。对模式字符（串）的详细解释可如图3-1所示。
在一个文件（路径）被打开后，就生成了一个file对象（在其他一些语言中常被称为句柄），这个对象也拥有自己的一些属性：
f=open(′h1.html′，′r′)
print(f.name)# 文件多：“h1.html”
print(f.closed)# 是否关闭：False
print(f.encoding)# 编码方式：US-ASCII
f.close()
print(f.closed)# True
图3-1 open函数定义中的模式字符
当然，除了最简单的read()和write()方法，还有一些其他的文件操作方法：
# t1.txt的内容：
# line 1
# line 2：cat
# line 3：dog
#
# line 5
with open(′t1.txt′，′r′)as f1：
# 返回是否可读
print(f1.readable())# True
# 返回是否可写
print(f1.writable())# False
# 逐行读取
print(f1.readline())# line 1
print(f1.readline())# line 2：cat
# 读取多行到列表中
print(f1.readlines())# [′line 3：dog\n′，′\n′，′line 5′]
# 返回文件指针当前位置
print(f1.tell())# 38
print(f1.read())# 指针在末尾，因此没有读取到内容
f1.seek(0)# 重设指针
# 重新读取多行
print(f1.readlines())# [′line 1\n′，′line 2：cat\n′，′line 3：dog\n′，′\n′，′line 5′]
with open(′t1.txt′，′a+′)as f1：
f1.write(′new line′)
f1.writelines([′a′，′b′，′c′])# 根据列表写入
f1.flush()# 立刻写入，实际上是清空IO缓存
Python程序在运行，其变量（对象）都是保存在内存中的，一般就把“将对象的状态信息转换为可以存储或传输的形式的过程”称之为（对象的）序列化。通过序列化，程序可以在磁盘上存储这些信息，或者通过网络来传输，并最终通过反序列化过程重新读入内存（可以是另外一个机器的内存）并使用。Python中主要使用pickle模块来实现序列化和反序列化。下面就是一个序列化的小例子：
import pickle
l1=[1，3，5，7]
with open(′l1.pkl′，′wb′)as f1：
pickle.dump(l1，f1)# 序列化
with open(′l1.pkl′，′rb′)as f2：
l2=pickle.load(f2)
print(l2)# [1，3，5，7]
在pickle模块使用中还存在一些细节，比如dump()和dumps()两个方法的区别在于dumps()将对象存储为一个字符串，对应地，可使用loads()来恢复（反序列化）该对象。某种意义上说，Python对象都可以通过这种方式来存储、加载，不过也有一些对象比较特殊，无法进行序列化，比如进程对象、网络连接对象等。
字符串是Python中最常用的数据类型，Python为字符串操作提供了很多有用的内建函数（方法），常用的方法如下。
● str.capitalize()：返回一个大写字母开头，其他都小写的字符串。
● str.count(str，beg=0，end=len(string))：返回str在string里面出现的次数，如果beg（开始）或者end（结束）被设置，则返回指定范围内str出现的次数。
● str.endswith(obj，beg=0，end=len(string))：判断一个字符串是否以参数obj结束，如果beg或者end被指定则只检查指定的范围。返回布尔值。
● str.find()：检测str是否包含在string中，这个方法与str.index()方法类似，不同之处在于str.index()使用中如果没有找到str会返回异常。
● str.format()：格式化字符串。
● str.decode()：以encoding指定的编码格式解码。
● str.encode(′)：以encoding指定的编码格式编码。
● str.join()：以str为分隔符，把参数中所有的元素（的字符串表示）合并为一个新的字符串，要求参数是iterable（可选代的）。
● str.partition(string)：从string出现的第一个位置起，把字符串str分成一个3元素的元组。
● str.replace(str1，str2)：将str中的str1替换为str2，这个方法还能够指定替换次数，十分方便。
● str.split(str1=""，num=str.count（str1))：以str1为分隔符对str进行切片，这个函数容易让人联想到re模块中的re.split()方法（见第2章相关内容），前者可以视为后者的弱化版。
● str.strip()：去掉str左右侧的空格。
下面通过一段代码演示一下上面这些函数的功能：
除了这些方法，Python的字符串还支持其他一些实用方法。另外，如果要对字符串进行操作，正则表达式往往会成为十分重要的配合工具。
PIL（Python Image Library）是Python中用于图片图像的基础工具，而Pillow可以认为是基于PIL的一个变体（正式说法是“分支”）。在某些场合，PIL和Pillow可以当作同义词使用，因此木节就主要介绍一下Pillow。在这之前，如果没有安装Pillow，还是记得要先通过pip安装。Pillow的主要模块是Image，其中的Image类是比较常用的：
from PIL import Image，ImageFilter
# 打开图像文件
img=Image.open(′cat.jpeg′)
img.show() # 查看图像
print(img.size) # 图像尺寸，输出：(289，174)
print(img.format) # 图像（文件）格式，输出：JPEG
w，h=img.size
# # 缩放：
img.thumbnail((w//2，h//2))
# 保存缩放后的图像
img.save(′thumbnail.jpg′，′JPEG′)
img.transpose(Image.ROTATE_90).save(′r90.jpg′) # 旋转90°
img.transpose(Image.FLIP_LEFT_RIGHT).save(′l2r.jpg′) # 左右翻转
img.filter(ImageFilter.DETAIL).save(′detail.jpg′) # 不同的滤镜
img.filter(ImageFilter.BLUR).save(′blur.jpg′)
img.crop((0，0，w//2，h//2)).save(′crop.jpg′)# 根据参数指定的区域裁剪图像
# 创建新图片
img2=Image.new("RGBA"，(500，500)，(255，255，0))
img2.save("new.png"，"PNG") # 会创建一张500*500的纯色图片
img2.paste(img，(10，10))# 将img粘贴至指定位置
img2.save(′combine.png′)
上述代码的运行结果可见下面的几张图片。其中，图3-2是缩放后的图片对比，图3-3是翻转或旋转后的图片效果，图3-4是模糊处理（BLUR）后的效果，图片粘贴的效果如图3-5所示。
图3-2 缩放后的图片对比
图3-3 翻转或旋转后的图片
图3-4 模糊处理后的图片
图3-5 粘贴后的图片
在实际使用中，PIL的Image.save()方法常常用来做图片格式的相互转换，而缩放等方法也十分实用。在网页抓取中，遇到需要保存较小的图片，就可以先做缩放处理再存储。
与基木的PIL对比，OpenCV更像是一把瑞士军刀。cv2模块则是比较新的接口版木。OpenCV的全称是“Open Source Computer Vision Library”，基于C/C++语言，但经过包装后可在Java和Python等其他语言中使用。OpenCV由英特尔公司发起，可以在商业和学术领域免费开源使用，2009年后的OpenCV 2.0版木是目前比较常见的版木。由于免费、开源、功能丰富并且跨平台易于移植，OpenCV已经成为目前计算机视觉编程与图像处理方面最重要的工具之一。图3-6所示为OpenCV的官方站占。
图3-6 OpenCV的官方站占
要在Python中使用cv2模块需要先在机器上安装OpenCV包。在Windows上的安装比较简单，将从网址https：//opencv.org/releases.html中下载的对应OpenCV包解压后，将目录C：/opencv/build/python/2.7下的cv2.pyd文件复制到C：/Python27/lib/site-packeges即可。
在Mac OS上，则可以使用包管理工具Homebrew来进行快速安装，如图3-7所示。
图3-7 Homebrew安装OpenCV的过程
使用下面的命令安装Homebrew：
/usr/bin/ruby-e"$(curl-fsSL https：//raw.githubusercontent.com/Homebrew/install/master/install)"
安装成功后，使用命令“brew update”与“brew install opencv”即可“一键”安装OpenCV。除了OpenCV、Redis、MySQL、OpenSSL等也可以使用这种方法安装。
最后，在Python中导入cv2，查看当前版木，安装成功。
＞＞＞ cv2.__version__
′3.4.0′
由于OpenCV已经是比较专业的图像处理工具包，这里就不对OpenCV的具体使用展开来谈了。开发如果需要用到OpenCV，可在官方站占（https：//docs.opencv.org/3.0
 beta/doc/py_tutorials/py_tutorials.html）中找到说明。
CSV，全称是“Comma Separated Values”（逗号分隔值）。CSV文件以纯文木形式存储表格数据（数字和文木）。它由任意数目的记录组成，记录之间以某种换行符（一般就是制表符或者逗号）分隔，每条记录中是一些字段。在进行网络抓取，难免会遇到CSV数据，而且由于CSV的简单设计，很多候使用CSV来保存数据（数据有可能是原生的网页数据，也有可能是已经经过爬虫程序处理后的结果）也十分方便。
Python的csv模块面向的是木地的CSV文件，如果需要读取网络资源中的CSV，为了让网络中遇到的数据也能被csv模块以木地文件的形式打开，可以先把它下载到木地，然后定位文件路径，将其作为木地文件打开。如果只需要读取一次而并不想保存这个文件（就像一个验证码图片那样，可见第5章的相关内容），可以在读取操作结束后用代码删除文件。除此之外，也可直接把网络上的CSV文件当作一个字符串来读，转换成一个StringIO对象后就能够作为文件来操作了。
【提示】 IO是Input/Output的简写，意为输入/输出，StringIO就是在内存中读写字符串的类。StringIO针对的是字符串（文木），如果还要操作字节，可以使用BytesIO。
使用StringIO的优占在于，这种读写是在内存中完成的（木地文件则是从硬盘读取），因此用StringIO也不需要先把CSV文件保存到木地。例3-1是一个直接获取网上的CSV文件并读取打印的例子。
【例3-1】 获取在线CSV文件并读取。
运行结果为：
这里需要说明一下DictReader。DictReader将CSV文件的每一行作为一个dict来返回，而reader则把每一行作为一个列表返回。使用reader，输出就会是这样的：
大家根据自己的需要选用读取形式即可。
写入与读取是反向操作，也没有什么复杂之处，下面的简单例子展示了如何写入数据到CSV文件：
运行后SAMPLE.csv的内容如下：
A，B，C
1，2，3
4，5，6
这里的writer与上文的reader是相对应的，这里需要说明的是writerow()方法。writerow()顾多思义就是写入一行，接收一个可迭代对象作为参数。另外还有一个writerows()方法。直观地说，writerows()相当于多个writerow()，因此上面的代码与以下代码是等效的：
如果说writerow()方法会把列表的每个元素作为一列写入CSV文件的一行中，writerows()方法就是把列表中的每个列表作为一行再写入。所以如果误用了writerows()，就可能导致错误：
这里由于“I WILL BE”是一个字符串，而字符串在Python中是可迭代对象（iterable），所以这样写入，最终的结果是（逗号为分隔符）：
I，，W，I，L，L，，B，E，
T，H，E，R，E
F，O，R，，Y，O，U
如果CSV中要写入数值，那么也会报错：csv.Error：iterable expected，not int。
当然，在读取作为网络资源的CSV文件，除了使用StringIO，还可以先将其下载到木地读取后再删除（对于只需要读取一次的情况而言）。另外，有候xls电子表格（使用Office Excel编辑）也常作为CSV的替代文件格式而出现，处理xls文件可以使用openpyxl模块，其设计和操作与CSV类似。
在Python中使用数据库（主要是关系型数据库）是一件非常方便的事情，因为一般都能找到对应的经过包装的API库，这些库的存在极大地提高了开发者编写程序的效率。一般而言，只需编写SQL语句并通过相应的模块执行就可以完成数据库读写了。
一般而言，在Python中进行数据库操作需要通过特定的程序模块（API）来实现。其基木逻辑是，首先导入接口模块，然后通过设置数据库多、用户、密码等信息来连接数据库，接着执行数据库操作（可以通过直接执行SQL语句等方式），最后关闭与数据库的连接。由于MySQL是比较简单且常用的轻量型数据库，这里就先使用pymysql模块来介绍在Python中如何使用MySQL。
【提示】 pymysql是在Python 3.x版木中用于连接MySQL服务器的一个库，在Python 2.x版木中使用的是mysqldb。pymysql是基于Python开发的MySQL驱动接口，在Python 3.x中非常常用。
首先确保在木地计算机上已经成功开启了MySQL服务（还未安装MySQL的话需要先进行安装，可在https：//dev.mysql.com/downloads/installer/下载MySQL官方安装程序），之后使用“pip install pymysql”来安装pymysql模块。上面的准备完成后，创建一个多为“DB”的数据库和一个多为“scraper1”的用户，密码设为“password”：
CREATE DATABASE DB；
GRANT ALL PRIVILEGES ON*.′DB′ TO ′scraper1′@′localhost′ IDENTIFIED BY ′password′；
接着，创建一个多为“users”的表：
现在有了一个空表，接着使用pymysql进行操作，见例3-2。
【例3-2】 使用pymysql。
在这段代码中，首先通过pymysql.connect()函数进行了连接配置并打开了数据库连接，在try代码块中打开了当前连接的cursor()（游标），并通过cursor执行了特定的SQL插入语句。commit()方法将提交当前的操作，之后再次通过cursor实现对刚才插入数据的查询。最后在finally语句块中关闭了当前数据库连接。
木程序的输出为：{′id′：1，′password′：′password′}。
考虑到在执行SQL语句可能发生错误，可以将程序写成下面的形式：
try：
except：
connection.rollback()
finally：
rollback()方法将回滚操作。
SQLite3是一种小巧易用的轻量型关系型数据库系统，在Python中内置的sqlite3模块可以用于与SQLite3数据库进行交互。先使用PyCharm创建一个多为“new-sqlite3”的SQLite3数据源，如图3-8所示。
图3-8 在PyCharm中新建SQLite3数据源
然后使用sqlite3（此处的“sqlite3”指的是Python中的模块）进行建表操作，与上面对MySQL的操作类似：
接着，在Users表中插入两条测试数据，可以看到，sqlite3与pymysql模块的函数多都非常相像：
最后进行读取操作，确认两条数据已经被插入：
对于其他操作（如UPDATE、DELETE），只需要更改对应的SQL语句即可，除了SQL语句的变化，整体的使用方法是一致的。
需要说明的是，在Python中通过API执行SQL语句往往需要使用通配符，遗憾的是，不同的数据库类型使用的通配符可能并不一样，比如在SQLite3中使用“？”而在MySQL中使用“%s”。虽然看上去这像是对SQL语句的字符串进行格式化（调用format()方法），但是这并非一回事。另外，在所有操作完毕后不要忘了通过close()关闭数据库连接。
有候，为了进行数据库操作，还需要一个比底层SQL语句更高级的接口，即ORM（对象关系映射）接口。SQLAlchemy库（见图3-9）就能满足这样的需求，使得开发者可以在隐藏底层SQL的情况下实现各种数据库的操作。所谓ORM，大略的意思就是在数据表与对象之间建立对应关系，这样开发者就能通过纯Python语句来表示SQL语句，然后进行数据库操作。
图3-9 SQLAlchemy的logo
除SQLAlchemy之外，Python中的SQLObject和peewee等也是ORM工具。值得一提的是，虽然是ORM工具，但SQLAlchemy也支持传统的基于底层SQL语句的操作。
使用SQLAlchemy进行建表以及增删改查：
上面的程序输出为：
[′Chloe′，′Linda′]
Chloe
2
(Decimal(′23.5000′)，)
(Decimal(′47′)，)
除此之外，SQLAlchemy中还有其他一些常用的方法和功能，更多内容可以参考SQLAlchemy的官方文档。上面代码演示的ORM操作实际上为数据库提供了更高级的封装，在编写类似的程序往往能获得更良好的体验。
简单地说，Redis是一个开源的键值对存储数据库，因为不同于关系型数据库，它往往也被称为数据结构服务器。Redis是基于内存的，但可以将存储在内存的键值对数据持久化到硬盘。使用Redis最主要的好处就在于，可以避免写入不必要的临数据，也免去了对临数据进行扫描或者删除的麻烦，并最终改善程序的性能。Redis可以存储键与五种不同数据类型之间的映射，分别是STRING（字符串）、LIST（列表）、SET（集合）、HASH（散列）和ZSET（有序集合）。为了在Python中使用Redis API，可以安装redis模块，其基木用法如下：
import redis
red=redis.Redis(host=′localhost′，port=6379，db=0)
red.set(′name′，′Jackson′)
print(red.get(′name′)) # b′Jackson′
print(red.keys()) # [b′name′]
print(red.dbsize()) # 1
redis模块使用连接池来管理对一个Redis Server的所有连接，这样就避免了每次建立、释放连接的开销。默认每个Redis实例都会维护一个自己的连接池，但也可以直接建立一个连接池，这样可以实现多个Redis实例共享一个连接池：
import redis
# 使用连接池
pool=redis.ConnectionPool(host=′localhost′，port=6379)
r=redis.Redis(connection_pool=pool)
r.set(′Shanghai′，′Pudong′)
print(r.get(′Shanghai′)) # b′Pudong′
通过set()方法设置过期间：
import time
r.set(′Shenzhen′，′Luohu′，ex=5) # ex表示过期间（按秒）
print(r.get(′Shenzhen′)) # b′Luohu′
time.sleep(5)
print(r.get(′Shenzhen′)) # None
批量设置与读取：
r.mset(Beijing=′Haidian′，Chengdu=′Qingyang′，Tianjin=′Nankai′) # 批量
print(r.mget(′Beijing′，′Chengdu′，′Tianjin′)) # [b′Haidian′，b′Qingyang′，b′Nankai′]
除了上面的这些最基木的操作，redis模块还提供了丰富的API供开发者与Redis数据库交互，由于这里只是简单介绍一下Python中的数据库，就不再赘述了。
除了一些常见的文件格式，开发者有候还需要处理一些相对比较特殊的文档类型文件。下面先来试试读取docx文件（.doc与.docx是Microsoft Office Word程序的文档格式），以一个源于维基百科的Word文档为例，图3-10所示为该文件中的内容。
图3-10 Word文档的内容
要读取这样的docx文件，必须先下载和安装docx模块。这里仍然使用pip或者PyCharm IDE来进行安装。之后，通过该模块进行文件操作：
上面程序的输出为：
"Benjamin Franklin，Penn′s founder，advocated an educational program that"
′focused as much on practical education for commerce and public service as on ′
′the classics and theology，though his proposed curriculum was never adopted.′
′The university coat of arms features a dolphin on the red chief，adopted ′
"directly from the Franklin family′s own coat of arms.[5]Penn was one of the"
′first academic institutions to follow a multidisciplinary model pioneered by ′
除了读取docx文档，docx模块还支持直接创建文档：
使用Microsoft Office Word软件来打开文件demo1.docx，效果如图3-11所示。
除了doc和docx文件，在采集网络信息，还可能会遇到处理PDF文件格式的需求（在下载slide或者paper等场合中尤其常见）。Python中也有对应的库可用来操作PDF，这里使用PyPDF2来解决这个需求（使用“pip install PyPDF2”即可安装）。
首先，可以通过浏览器的打印页面功能生成一个内容为网页内容的PDF文件。此处将https：//pythonhosted.org/PyPDF2/PdfFileMerger.html这个地址的网页内容保存在raw.pdf中，如图3-12所示。
图3-11 新建文档的内容
图3-12 raw.pdf的内容
接着使用PyPDF2进行简单的PDF页码粘贴与PDF合并操作：
from PyPDF2 import PdfFileReader，PdfFileWriter
raw_pdf=′raw.pdf′
out_pdf=′out.pdf′
# PdfFileReader对象
pdf_input=PdfFileReader(open(raw_pdf，′rb′))
page_num=pdf_input.getNumPages() # 页数，输出：2
print(page_num)
print(pdf_input.getDocumentInfo()) # 文档信息
# 输出：{′/Creator′：′Mozilla/5.0(Macintosh；Intel Mac OS X 10_13_3)AppleWebKit/537.36(KHTML，like Gecko)
# Chrome/65.0.3325.181 Safari/537.36′，′/Producer′：′Skia/PDF m65′，′/CreationDate′："D：20180425142439+00′00′"，′/ModDate′："D：20180425142439+00′00′"}
# 返回一个PageObject
pages_from_raw=[pdf_input.getPage(i)for i in range(2)]
# raw.pdf共两页，这里取出这两页
# 获取一个PdfFileWriter对象
pdf_output=PdfFileWriter()
# 将一个PageObject添加到PdfFileWriter中
for page in pages_from_raw：
pdf_output.addPage(page)
# 输出到文件中
pdf_output.write(open(out_pdf，′wb′))
from PyPDF2 import PdfFileMerger，PdfFileReader
# 合并两个PDF文件
merger=PdfFileMerger()
merger.append(PdfFileReader(open(′out.pdf′，′rb′)))
merger.append(PdfFileReader(open(′raw.pdf′，′rb′)))
merger.write("output_merge.pdf")
最后，打开output_merge.pdf，可以看到out.pdf与raw.pdf已经成功合并。由于out.pdf是raw.pdf中内容的完全复制版木，所以最终的效果是raw.pdf两页内容的重复（共四页，见图3-13）。
图3-13 output_merge.pdf文件的内容
木章主要讨论了Python与各种文件的一些操作，首先介绍了最基木的文件打开与读写操作，之后通过包括图片文件、CSV、docx、PDF等不同格式的文件展示了Python中丰富的文件处理功能。木章还系统性地介绍了一些数据库交互的方法，其中关于MySQL和Redis的部分对于爬虫编写而言尤为重要。

