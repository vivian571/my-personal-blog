# 第6节：全栈框架_模型层

## 来源

模型层是Django框架中负责数据定义和操作的核心组件。在Django的MTV（Model-Template-View）架构中，模型代表应用程序的数据结构，定义了数据库表的结构、字段类型、关系以及数据操作方法。Django的ORM（对象关系映射）系统将Python类映射到数据库表，使开发者能够使用Python代码而非SQL语句来操作数据库，大大简化了数据库操作，提高了开发效率。

## 定义

### 模型层的概念

模型层是Web应用程序中负责数据定义和操作的组件。在Django中，模型层由以下部分组成：

1. **模型类**：继承自`django.db.models.Model`的Python类，定义数据结构。
2. **字段**：模型类的属性，定义数据类型和约束。
3. **管理器**：提供数据库查询接口，默认为`objects`。
4. **元数据**：定义模型的附加信息，如排序、表名等。

### 模型定义

模型类是Django ORM的核心，它定义了数据的结构和行为：

```python
from django.db import models
from django.contrib.auth.models import User

class Category(models.Model):
    name = models.CharField(max_length=100)
    slug = models.SlugField(unique=True)
    description = models.TextField(blank=True)
    
    class Meta:
        verbose_name_plural = "categories"
        ordering = ["name"]
    
    def __str__(self):
        return self.name
    
    def get_absolute_url(self):
        from django.urls import reverse
        return reverse("category_detail", kwargs={"slug": self.slug})

class Article(models.Model):
    STATUS_CHOICES = (
        ("draft", "草稿"),
        ("published", "已发布"),
    )
    
    title = models.CharField(max_length=200)
    slug = models.SlugField(unique_for_date="published_date")
    author = models.ForeignKey(User, on_delete=models.CASCADE, related_name="articles")
    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True, related_name="articles")
    content = models.TextField()
    published_date = models.DateTimeField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default="draft")
    
    class Meta:
        ordering = ["-published_date"]
        indexes = [models.Index(fields=["-published_date"])]
    
    def __str__(self):
        return self.title
    
    def get_absolute_url(self):
        from django.urls import reverse
        return reverse("article_detail", kwargs={
            "year": self.published_date.year,
            "month": self.published_date.month,
            "day": self.published_date.day,
            "slug": self.slug
        })
```

### 字段类型

Django提供了丰富的字段类型，用于定义不同类型的数据：

1. **字符串字段**：
   - `CharField`：固定长度的字符串
   - `TextField`：不限长度的文本
   - `SlugField`：URL友好的字符串
   - `EmailField`：电子邮件地址
   - `URLField`：URL地址

2. **数值字段**：
   - `IntegerField`：整数
   - `FloatField`：浮点数
   - `DecimalField`：固定精度的十进制数
   - `PositiveIntegerField`：正整数

3. **日期时间字段**：
   - `DateField`：日期
   - `TimeField`：时间
   - `DateTimeField`：日期和时间
   - `DurationField`：时间间隔

4. **布尔字段**：
   - `BooleanField`：布尔值（True/False）
   - `NullBooleanField`：可为空的布尔值

5. **文件字段**：
   - `FileField`：文件上传
   - `ImageField`：图片上传

6. **关系字段**：
   - `ForeignKey`：一对多关系
   - `ManyToManyField`：多对多关系
   - `OneToOneField`：一对一关系

### 字段选项

字段选项用于定义字段的约束和行为：

1. **通用选项**：
   - `null`：是否允许为NULL（数据库层面）
   - `blank`：是否允许为空（表单验证层面）
   - `default`：默认值
   - `help_text`：帮助文本
   - `verbose_name`：字段的可读名称
   - `unique`：是否唯一
   - `choices`：预定义的选项

2. **关系字段选项**：
   - `on_delete`：当关联对象被删除时的行为
   - `related_name`：反向关系名称
   - `limit_choices_to`：限制可选择的对象

### 模型查询

Django ORM提供了强大的查询API，用于从数据库中检索数据：

```python
# 获取所有文章
articles = Article.objects.all()

# 获取已发布的文章
published_articles = Article.objects.filter(status="published")

# 获取特定作者的文章
user_articles = Article.objects.filter(author__username="admin")

# 获取标题包含特定关键词的文章
search_articles = Article.objects.filter(title__contains="Django")

# 获取最近发布的5篇文章
recent_articles = Article.objects.filter(status="published").order_by("-published_date")[:5]

# 获取特定ID的文章，如果不存在则抛出异常
article = Article.objects.get(id=1)

# 获取特定ID的文章，如果不存在则返回None
try:
    article = Article.objects.get(id=1)
except Article.DoesNotExist:
    article = None

# 使用get_object_or_404获取对象，如果不存在则返回404响应
from django.shortcuts import get_object_or_404
article = get_object_or_404(Article, id=1)
```

### 模型管理器

模型管理器是Django ORM的接口，提供了数据库查询方法。可以自定义管理器来添加特定的查询方法：

```python
class PublishedManager(models.Manager):
    def get_queryset(self):
        return super().get_queryset().filter(status="published")

class Article(models.Model):
    # ...
    objects = models.Manager()  # 默认管理器
    published = PublishedManager()  # 自定义管理器
    
    # ...

# 使用自定义管理器
published_articles = Article.published.all()
```

## 案例

### 模型定义示例

```python
# blog/models.py
from django.db import models
from django.contrib.auth.models import User
from django.utils import timezone
from django.urls import reverse

class Category(models.Model):
    name = models.CharField(max_length=100, verbose_name="分类名称")
    slug = models.SlugField(unique=True, verbose_name="URL别名")
    description = models.TextField(blank=True, verbose_name="分类描述")
    
    class Meta:
        verbose_name = "分类"
        verbose_name_plural = "分类"
        ordering = ["name"]
    
    def __str__(self):
        return self.name
    
    def get_absolute_url(self):
        return reverse("blog:category_detail", kwargs={"slug": self.slug})

class Tag(models.Model):
    name = models.CharField(max_length=50, verbose_name="标签名称")
    slug = models.SlugField(unique=True, verbose_name="URL别名")
    
    class Meta:
        verbose_name = "标签"
        verbose_name_plural = "标签"
        ordering = ["name"]
    
    def __str__(self):
        return self.name
    
    def get_absolute_url(self):
        return reverse("blog:tag_detail", kwargs={"slug": self.slug})

class PublishedManager(models.Manager):
    def get_queryset(self):
        return super().get_queryset().filter(status="published")

class Article(models.Model):
    STATUS_CHOICES = (
        ("draft", "草稿"),
        ("published", "已发布"),
    )
    
    title = models.CharField(max_length=200, verbose_name="标题")
    slug = models.SlugField(unique_for_date="published_date", verbose_name="URL别名")
    author = models.ForeignKey(
        User, 
        on_delete=models.CASCADE, 
        related_name="articles",
        verbose_name="作者"
    )
    category = models.ForeignKey(
        Category, 
        on_delete=models.SET_NULL, 
        null=True, 
        blank=True,
        related_name="articles",
        verbose_name="分类"
    )
    tags = models.ManyToManyField(
        Tag, 
        blank=True, 
        related_name="articles",
        verbose_name="标签"
    )
    content = models.TextField(verbose_name="内容")
    summary = models.TextField(blank=True, verbose_name="摘要")
    featured_image = models.ImageField(
        upload_to="blog/images/%Y/%m/", 
        blank=True, 
        null=True,
        verbose_name="特色图片"
    )
    published_date = models.DateTimeField(null=True, blank=True, verbose_name="发布时间")
    created_at = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
    updated_at = models.DateTimeField(auto_now=True, verbose_name="更新时间")
    status = models.CharField(
        max_length=10, 
        choices=STATUS_CHOICES, 
        default="draft",
        verbose_name="状态"
    )
    views = models.PositiveIntegerField(default=0, verbose_name="浏览量")
    allow_comments = models.BooleanField(default=True, verbose_name="允许评论")
    
    objects = models.Manager()  # 默认管理器
    published = PublishedManager()  # 自定义管理器
    
    class Meta:
        verbose_name = "文章"
        verbose_name_plural = "文章"
        ordering = ["-published_date"]
        indexes = [
            models.Index(fields=["-published_date"]),
            models.Index(fields=["status"]),
        ]
    
    def __str__(self):
        return self.title
    
    def get_absolute_url(self):
        if self.published_date:
            return reverse("blog:article_detail", kwargs={
                "year": self.published_date.year,
                "month": f"{self.published_date.month:02d}",
                "day": f"{self.published_date.day:02d}",
                "slug": self.slug
            })
        return reverse("blog:article_detail_by_id", kwargs={"pk": self.pk})
    
    def save(self, *args, **kwargs):
        if not self.summary:
            # 如果没有提供摘要，则自动生成
            self.summary = self.content[:200].replace("\n", " ")
        if self.status == "published" and not self.published_date:
            # 如果状态为已发布且没有发布时间，则设置为当前时间
            self.published_date = timezone.now()
        super().save(*args, **kwargs)
    
    def increase_views(self):
        # 增加浏览量
        self.views += 1
        self.save(update_fields=["views"])

class Comment(models.Model):
    article = models.ForeignKey(
        Article, 
        on_delete=models.CASCADE, 
        related_name="comments",
        verbose_name="文章"
    )
    author_name = models.CharField(max_length=100, verbose_name="作者名称")
    author_email = models.EmailField(verbose_name="作者邮箱")
    author_url = models.URLField(blank=True, verbose_name="作者网站")
    content = models.TextField(verbose_name="评论内容")
    created_at = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
    is_approved = models.BooleanField(default=False, verbose_name="是否批准")
    
    class Meta:
        verbose_name = "评论"
        verbose_name_plural = "评论"
        ordering = ["created_at"]
    
    def __str__(self):
        return f"{self.author_name}对{self.article}的评论"
```

### 模型查询示例

```python
# blog/views.py
from django.shortcuts import render, get_object_or_404
from django.utils import timezone
from .models import Article, Category, Tag

def article_list(request):
    # 获取所有已发布的文章
    articles = Article.published.all()
    return render(request, "blog/article_list.html", {"articles": articles})

def article_detail(request, year, month, day, slug):
    # 获取特定日期和别名的文章
    article = get_object_or_404(
        Article.published,
        published_date__year=year,
        published_date__month=month,
        published_date__day=day,
        slug=slug
    )
    # 增加浏览量
    article.increase_views()
    # 获取文章的评论
    comments = article.comments.filter(is_approved=True)
    return render(request, "blog/article_detail.html", {
        "article": article,
        "comments": comments
    })

def category_articles(request, slug):
    # 获取特定分类
    category = get_object_or_404(Category, slug=slug)
    # 获取该分类下的所有已发布文章
    articles = Article.published.filter(category=category)
    return render(request, "blog/category_articles.html", {
        "category": category,
        "articles": articles
    })

def tag_articles(request, slug):
    # 获取特定标签
    tag = get_object_or_404(Tag, slug=slug)
    # 获取包含该标签的所有已发布文章
    articles = Article.published.filter(tags=tag)
    return render(request, "blog/tag_articles.html", {
        "tag": tag,
        "articles": articles
    })

def search_articles(request):
    # 获取搜索关键词
    query = request.GET.get("q", "")
    if query:
        # 在标题和内容中搜索关键词
        articles = Article.published.filter(
            models.Q(title__icontains=query) | models.Q(content__icontains=query)
        )
    else:
        articles = Article.published.none()
    return render(request, "blog/search_results.html", {
        "query": query,
        "articles": articles
    })
```

### 模型表单示例

```python
# blog/forms.py
from django import forms
from .models import Article, Comment

class ArticleForm(forms.ModelForm):
    class Meta:
        model = Article
        fields = ["title", "slug", "category", "tags", "content", "summary", 
                 "featured_image", "status", "allow_comments"]
        widgets = {
            "title": forms.TextInput(attrs={"class": "form-control"}),
            "slug": forms.TextInput(attrs={"class": "form-control"}),
            "category": forms.Select(attrs={"class": "form-select"}),
            "tags": forms.SelectMultiple(attrs={"class": "form-select"}),
            "content": forms.Textarea(attrs={"class": "form-control", "rows": 10}),
            "summary": forms.Textarea(attrs={"class": "form-control", "rows": 3}),
            "status": forms.Select(attrs={"class": "form-select"}),
            "allow_comments": forms.CheckboxInput(attrs={"class": "form-check-input"}),
        }

class CommentForm(forms.ModelForm):
    class Meta:
        model = Comment
        fields = ["author_name", "author_email", "author_url", "content"]
        widgets = {
            "author_name": forms.TextInput(attrs={"class": "form-control"}),
            "author_email": forms.EmailInput(attrs={"class": "form-control"}),
            "author_url": forms.URLInput(attrs={"class": "form-control"}),
            "content": forms.Textarea(attrs={"class": "form-control", "rows": 5}),
        }
```

### 模型管理员示例

```python
# blog/admin.py
from django.contrib import admin
from .models import Category, Tag, Article, Comment

@admin.register(Category)
class CategoryAdmin(admin.ModelAdmin):
    list_display = ["name", "slug"]
    prepopulated_fields = {"slug": ("name",)}
    search_fields = ["name"]

@admin.register(Tag)
class TagAdmin(admin.ModelAdmin):
    list_display = ["name", "slug"]
    prepopulated_fields = {"slug": ("name",)}
    search_fields = ["name"]

class CommentInline(admin.TabularInline):
    model = Comment
    extra = 0
    readonly_fields = ["author_name", "author_email", "author_url", "created_at"]

@admin.register(Article)
class ArticleAdmin(admin.ModelAdmin):
    list_display = ["title", "author", "category", "status", "published_date", "views"]
    list_filter = ["status", "created_at", "published_date", "author", "category"]
    search_fields = ["title", "content"]
    prepopulated_fields = {"slug": ("title",)}
    raw_id_fields = ["author"]
    date_hierarchy = "published_date"
    ordering = ["-published_date"]
    filter_horizontal = ["tags"]
    readonly_fields = ["views", "created_at", "updated_at"]
    fieldsets = [
        (None, {"fields": ["title", "slug"]}),
        ("内容", {"fields": ["content", "summary", "featured_image"]}),
        ("分类", {"fields": ["category", "tags"]}),
        ("发布信息", {"fields": ["author", "status", "published_date"]}),
        ("其他信息", {"fields": ["views", "allow_comments", "created_at", "updated_at"]}),
    ]
    inlines = [CommentInline]
    
    def save_model(self, request, obj, form, change):
        if not change:
            # 如果是新创建的文章，设置作者为当前用户
            obj.author = request.user
        super().save_model(request, obj, form, change)

@admin.register(Comment)
class CommentAdmin(admin.ModelAdmin):
    list_display = ["author_name", "article", "created_at", "is_approved"]
    list_filter = ["is_approved", "created_at"]
    search_fields = ["author_name", "author_email", "content"]
    actions = ["approve_comments"]
    
    def approve_comments(self, request, queryset):
        queryset.update(is_approved=True)
    approve_comments.short_description = "批准选中的评论"
```

## 总结

1. **Django的模型层提供了强大的ORM系统**，将Python类映射到数据库表，使开发者能够使用Python代码而非SQL语句来操作数据库，大大简化了数据库操作，提高了开发效率。

2. **模型类定义了数据的结构和行为**，包括字段、方法、元数据等，是Django应用程序的数据基础。

3. **Django提供了丰富的字段类型和选项**，满足各种数据存储需求，并支持字段验证、默认值、帮助文本等功能。

4. **模型查询API提供了强大的数据检索能力**，支持过滤、排序、聚合、分组等操作，使数据操作变得简单高效。

5. **自定义模型管理器**可以封装常用的查询逻辑，提高代码复用性和可维护性。

通过本节课，我们深入了解了Django的模型层，包括模型定义、字段类型、查询API、管理器等核心概念。这些知识将帮助我们设计合理的数据结构，高效地操作数据库，构建功能强大的Web应用程序。下一节将介绍Django的表单系统，进一步探讨如何处理用户输入和数据验证。